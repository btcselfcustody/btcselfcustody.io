"use strict";(self.webpackChunkmy_personal_website=self.webpackChunkmy_personal_website||[]).push([[162],{4853:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"coreboot/unlocking","title":"Unlocking BIOS","description":"Before flashing Coreboot internally, it\u2019s important to understand the security protections built into the BIOS and how older versions can be exploited to bypass them.","source":"@site/docs/coreboot/unlocking.md","sourceDirName":"coreboot","slug":"/coreboot/unlocking-bios/","permalink":"/docs/coreboot/unlocking-bios/","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"coreboot","permalink":"/docs/tags/coreboot"},{"inline":true,"label":"chipsec","permalink":"/docs/tags/chipsec"},{"inline":true,"label":"bios","permalink":"/docs/tags/bios"},{"inline":true,"label":"unlocking","permalink":"/docs/tags/unlocking"}],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Unlocking BIOS","slug":"/coreboot/unlocking-bios/","tags":["coreboot","chipsec","bios","unlocking"]},"sidebar":"tutorialCoreboot","previous":{"title":"Downgrading BIOS","permalink":"/docs/coreboot/downgrading-bios/"},"next":{"title":"Flashing","permalink":"/docs/coreboot/flashing/"}}');var t=s(4848),r=s(8453);const o={sidebar_position:5,title:"Unlocking BIOS",slug:"/coreboot/unlocking-bios/",tags:["coreboot","chipsec","bios","unlocking"]},l="Unlocking BIOS",c={},a=[{value:"Security Issues",id:"security-issues",level:2},{value:"1. SMM_BWP and BLE not enabled",id:"1-smm_bwp-and-ble-not-enabled",level:3},{value:"2. S3 Boot Script vulnerability",id:"2-s3-boot-script-vulnerability",level:3},{value:"Install CHIPSEC",id:"install-chipsec",level:2},{value:"Examining BIOS Protections (Theory)",id:"examining-bios-protections-theory",level:2},{value:"Requirements for Flashing",id:"requirements-for-flashing",level:3},{value:"Checking Current BIOS Lock Status",id:"checking-current-bios-lock-status",level:2},{value:"Step 1: Check the HSFS Register",id:"step-1-check-the-hsfs-register",level:3},{value:"Step 2: Check BIOS_CNTL and Protected Ranges (PR0\u2013PR4)",id:"step-2-check-bios_cntl-and-protected-ranges-pr0pr4",level:3},{value:"Step 3: Looking at the Raw Registers (Optional)",id:"step-3-looking-at-the-raw-registers-optional",level:3},{value:"Why This Matters",id:"why-this-matters",level:3},{value:"Removing Protections (Practice)",id:"removing-protections-practice",level:2},{value:"Step 1: Dump the S3 Boot Script",id:"step-1-dump-the-s3-boot-script",level:3},{value:"Step 2: Back Up Your BIOS Region (Important!)",id:"step-2-back-up-your-bios-region-important",level:3},{value:"Step 3: Patch the Boot Script",id:"step-3-patch-the-boot-script",level:3},{value:"Step 4: Apply the Patch by Sleeping and Resuming",id:"step-4-apply-the-patch-by-sleeping-and-resuming",level:3},{value:"Step 5: Remove Write Protection from BIOS Ranges",id:"step-5-remove-write-protection-from-bios-ranges",level:3},{value:"Step 6: Verify",id:"step-6-verify",level:3},{value:"Step 7: Flash Internally",id:"step-7-flash-internally",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"unlocking-bios",children:"Unlocking BIOS"})}),"\n",(0,t.jsx)(n.p,{children:"Before flashing Coreboot internally, it\u2019s important to understand the security protections built into the BIOS and how older versions can be exploited to bypass them."}),"\n",(0,t.jsx)(n.h2,{id:"security-issues",children:"Security Issues"}),"\n",(0,t.jsx)(n.p,{children:"Older factory BIOS versions for these ThinkPad models have multiple security weaknesses, but two of them are especially relevant for installing Coreboot without using an external programmer:"}),"\n",(0,t.jsx)(n.h3,{id:"1-smm_bwp-and-ble-not-enabled",children:"1. SMM_BWP and BLE not enabled"}),"\n",(0,t.jsx)(n.p,{children:"In BIOS versions released before 2014, both of these protections (SMM_BWP and BLE) are disabled by default."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why it matters:"})," When disabled, the BIOS can be written from the operating system without triggering extra security checks, making internal flashing possible.\nOur testing on multiple T430 and X230 BIOS versions confirmed that SMM_BWP = 1 only appears starting from the update whose changelog says:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"(New) Improved the UEFI BIOS security feature.\n"})}),"\n",(0,t.jsx)(n.p,{children:"This change effectively blocks normal internal flashing."}),"\n",(0,t.jsx)(n.h3,{id:"2-s3-boot-script-vulnerability",children:"2. S3 Boot Script vulnerability"}),"\n",(0,t.jsxs)(n.p,{children:["This flaw allowed changes to the system\u2019s resume-from-sleep instructions (S3 state). For more info visit this ",(0,t.jsx)(n.a,{href:"https://support.lenovo.com/eg/ru/product_security/s3_boot_protect",children:"link"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why it matters:"})," By modifying the boot script, it was possible to disable certain BIOS protections (such as the FLOCKDN bit) after waking from sleep, making the BIOS writable.\nThis vulnerability was later patched in newer BIOS versions."]}),"\n",(0,t.jsx)(n.h2,{id:"install-chipsec",children:"Install CHIPSEC"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://chipsec.github.io/",children:"CHIPSEC"})," is a framework for analyzing platform level security of hardware, devices, system firmware, low-level protection mechanisms, and the configuration of various platform components."]}),"\n",(0,t.jsx)(n.p,{children:"It contains a set of modules, including simple tests for hardware protections and correct configuration, tests for vulnerabilities in firmware and platform components, security assessment and fuzzing tools for various platform devices and interfaces, and tools acquiring critical firmware and device artifacts."}),"\n",(0,t.jsx)(n.p,{children:"To install CHIPSEC on your system follow the below steps."}),"\n",(0,t.jsx)(n.p,{children:"Install the dependencies:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"sudo apt install build-essential python3-dev python3 python-is-python3 gcc linux-headers-$(uname -r) nasm\n"})}),"\n",(0,t.jsx)(n.p,{children:"Clone the CHIPSEC repository on GitHub:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/chipsec/chipsec.git\ncd chipsec\n"})}),"\n",(0,t.jsx)(n.p,{children:"Build the Driver and Compression Tools"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"python setup.py build_ext -i\n"})}),"\n",(0,t.jsx)(n.h2,{id:"examining-bios-protections-theory",children:"Examining BIOS Protections (Theory)"}),"\n",(0,t.jsx)(n.p,{children:"On Intel platforms, there are two main mechanisms that protect the BIOS chip from being modified:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"BIOS_CNTL Register"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Located in the LPC Interface Bridge Registers (accessible through PCI configuration space at offset 0xDC).\nIt contains the following important bits:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SMM_BWP"})," (SMM BIOS Write Protect) \u2013 If set to 1, the BIOS can only be written from System Management Mode (SMM). Once enabled, it cannot be changed."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"BLE"})," (BIOS Lock Enable) \u2013 If set to 1, attempting to set BIOSWE to 1 will trigger a System Management Interrupt (SMI). Once enabled, it cannot be changed."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"BIOSWE"})," (BIOS Write Enable) \u2013 Controls whether the BIOS is writable. This bit is always read/write."]}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["SPI Protected Range Registers (",(0,t.jsx)(n.strong,{children:"PR0\u2013PR4"}),")"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These are part of the SPI Configuration Registers (addresses from SPIBAR + 0x74 to SPIBAR + 0x84).\nEach register defines a protected address range and includes a WP (Write Protect) bit, which determines whether writes are blocked for that range."}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"FLOCKDN Bit"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Found in the HSFS register (",(0,t.jsx)(n.code,{children:"SPIBAR + 0x04"}),").\nIf set to 1, the PR0\u2013PR4 registers are locked and cannot be modified. Once set, it cannot be cleared until a full power cycle reset."]}),"\n",(0,t.jsx)(n.h3,{id:"requirements-for-flashing",children:"Requirements for Flashing"}),"\n",(0,t.jsx)(n.p,{children:"For internal BIOS flashing to be possible, we ideally need:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"SMM_BWP = 0"}),"\n",(0,t.jsx)(n.li,{children:"BIOSWE = 1"}),"\n",(0,t.jsx)(n.li,{children:"BLE = 0"}),"\n",(0,t.jsx)(n.li,{children:"FLOCKDN = 0"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Or, all SPI Protected Range registers (PRx) should have ",(0,t.jsx)(n.code,{children:"WP = 0"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"checking-current-bios-lock-status",children:"Checking Current BIOS Lock Status"}),"\n",(0,t.jsx)(n.p,{children:"The goal here is to see whether your BIOS is locked against internal writes. We do this by inspecting certain chipset registers."}),"\n",(0,t.jsx)(n.h3,{id:"step-1-check-the-hsfs-register",children:"Step 1: Check the HSFS Register"}),"\n",(0,t.jsx)(n.p,{children:"Run:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"sudo python chipsec_main.py -m common.spi_lock\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This will display the Hardware Sequencing Flash Status (HSFS) register, located at ",(0,t.jsx)(n.code,{children:"SPIBAR + 0x04"}),"."]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Output"}),(0,t.jsx)("p",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"[x][ =======================================================================\n[x][ Module: SPI Flash Controller Configuration Locks\n[x][ =======================================================================\n[*] HSFS = 0xE009 << Hardware Sequencing Flash Status Register (SPIBAR + 0x4)\n    [00] FDONE            = 1 << Flash Cycle Done\n    [01] FCERR            = 0 << Flash Cycle Error\n    [02] AEL              = 0 << Access Error Log\n    [03] BERASE           = 1 << Block/Sector Erase Size\n    [05] SCIP             = 0 << SPI cycle in progress\n    [13] FDOPSS           = 1 << Flash Descriptor Override Pin-Strap Status\n    [14] FDV              = 1 << Flash Descriptor Valid\n    [15] FLOCKDN          = 1 << Flash Configuration Lock-Down\n"})})})]}),"\n",(0,t.jsx)(n.p,{children:"One of the most important bits here is:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"FLOCKDN (bit 15)"}),": \u201cFlash Configuration Lock-Down.\u201d"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"1 = Locked. You cannot change the SPI Protected Range (PR0\u2013PR4) registers until the next hardware reset."}),"\n",(0,t.jsx)(n.li,{children:"0 = Unlocked. You can edit the PR registers and remove write protection."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If you see:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"FLOCKDN = 1\n"})}),"\n",(0,t.jsx)(n.p,{children:"It means the SPI configuration is locked. We\u2019ll need to bypass this later if we want to disable write protection."}),"\n",(0,t.jsx)(n.h3,{id:"step-2-check-bios_cntl-and-protected-ranges-pr0pr4",children:"Step 2: Check BIOS_CNTL and Protected Ranges (PR0\u2013PR4)"}),"\n",(0,t.jsx)(n.p,{children:"Run:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"sudo python chipsec_main.py -m common.bios_wp\n"})}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Output"}),(0,t.jsx)("p",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:" [x][ =======================================================================\n [x][ Module: BIOS Region Write Protection\n [x][ =======================================================================\n [*] BC = 0x 8 << BIOS Control (b:d.f 00:31.0 + 0xDC)\n     [00] BIOSWE           = 0 << BIOS Write Enable\n     [01] BLE              = 0 << BIOS Lock Enable\n     [02] SRC              = 2 << SPI Read Configuration\n     [04] TSS              = 0 << Top Swap Status\n     [05] SMM_BWP          = 0 << SMM BIOS Write Protection\n [-] BIOS region write protection is disabled!\n\n [*] BIOS Region: Base = 0x00500000, Limit = 0x00BFFFFF\n SPI Protected Ranges\n ------------------------------------------------------------\n PRx (offset) | Value    | Base     | Limit    | WP? | RP?\n ------------------------------------------------------------\n PR0 (74)     | 00000000 | 00000000 | 00000000 | 0   | 0\n PR1 (78)     | 8BFF0B40 | 00B40000 | 00BFFFFF | 1   | 0\n PR2 (7C)     | 8B100B10 | 00B10000 | 00B10FFF | 1   | 0\n PR3 (80)     | 8ADE0AD0 | 00AD0000 | 00ADEFFF | 1   | 0\n PR4 (84)     | 8AAF0800 | 00800000 | 00AAFFFF | 1   | 0\n"})})})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Good:"})," On older BIOS versions, ",(0,t.jsx)(n.code,{children:"SMM_BWP = 0"})," and ",(0,t.jsx)(n.code,{children:"BLE = 0"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bad:"})," PR1\u2013PR4 have ",(0,t.jsx)(n.code,{children:"WP = 1"}),", meaning large portions of the BIOS region are write-protected even though BIOS_CNTL itself looks permissive."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-3-looking-at-the-raw-registers-optional",children:"Step 3: Looking at the Raw Registers (Optional)"}),"\n",(0,t.jsx)(n.p,{children:"Another way to examine SPI configuration registers is to dump the raw-mapped SPIBAR register space directly:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"sudo python chipsec_util.py mmio dump SPIBAR\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will show:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The base address of SPIBAR (e.g., ",(0,t.jsx)(n.code,{children:"0xFED1F800"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["All register values, including ",(0,t.jsx)(n.code,{children:"0x0004E009"})," at offset ",(0,t.jsx)(n.code,{children:"0x04"})," (HSFS)"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"[mmio] MMIO register range [0x00000000FED1F800:0x00000000FED1F800+00000200]:\n+00000000: 0BFF0500\n+00000004: 0004E009\n...\n"})}),"\n",(0,t.jsx)(n.h3,{id:"why-this-matters",children:"Why This Matters"}),"\n",(0,t.jsxs)(n.p,{children:["In theory, to flash the BIOS internally, you\u2019d just clear the WP bits in ",(0,t.jsx)(n.code,{children:"PR0\u2013PR4."}),"\nBut if ",(0,t.jsx)(n.code,{children:"FLOCKDN = 1"})," in HSFS, the chipset won\u2019t let you change those registers until the next hardware reset (and firmware will usually lock it again at boot)."]}),"\n",(0,t.jsxs)(n.p,{children:["That\u2019s why the later steps in the guide focus on modifying the S3 boot script\u2014to stop the firmware from setting ",(0,t.jsx)(n.code,{children:"FLOCKDN = 1"})," during resume, so we can remove the ",(0,t.jsx)(n.code,{children:"WP"})," bits."]}),"\n",(0,t.jsx)(n.h2,{id:"removing-protections-practice",children:"Removing Protections (Practice)"}),"\n",(0,t.jsx)(n.p,{children:"Normally, the FLOCKDN bit (which locks the SPI configuration) can only be cleared by a full hardware reset.\nThis reset happens not only on a full reboot, but also when waking the computer from S3 sleep (suspend to RAM)."}),"\n",(0,t.jsx)(n.p,{children:"When the system wakes from S3, the chipset restores all its settings by running a set of instructions called S3 Boot Scripts.\nThese scripts are stored in RAM, which means we can edit them before waking\u2014and change what the firmware does during resume."}),"\n",(0,t.jsx)(n.h3,{id:"step-1-dump-the-s3-boot-script",children:"Step 1: Dump the S3 Boot Script"}),"\n",(0,t.jsx)(n.p,{children:"Run:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"sudo python chipsec_util.py uefi s3bootscript\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This lists many entries. Look for one that writes to the HSFS register (",(0,t.jsx)(n.code,{children:"SPIBAR + 0x04"}),").\nIf your ",(0,t.jsx)(n.code,{children:"SPIBAR"})," address is ",(0,t.jsx)(n.code,{children:"0xFED1F800"}),", that\u2019s ",(0,t.jsx)(n.code,{children:"0xFED1F804"})," for HSFS."]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Output"}),(0,t.jsx)("p",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"Entry at offset 0x2B8F (len = 0x17, header len = 0x0):\n Data:\n 02 00 17 02 00 00 00 01 00 00 00 04 f8 d1 fe 00 |\n 00 00 00 09 e0 04 00                            |\n Decoded:\n   Opcode : S3_BOOTSCRIPT_MEM_WRITE (0x0002)\n   Width  : 0x02 (4 bytes)\n   Address: 0xFED1F804\n   Count  : 0x1\n   Values : 0x0004E009\n"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["That ",(0,t.jsx)(n.code,{children:"0x0004E009"})," value sets ",(0,t.jsx)(n.code,{children:"FLOCKDN = 1"}),", which we don\u2019t want."]}),"\n",(0,t.jsx)(n.h3,{id:"step-2-back-up-your-bios-region-important",children:"Step 2: Back Up Your BIOS Region (Important!)"}),"\n",(0,t.jsx)(n.p,{children:"Before making changes, back up the BIOS region so you can recover if something goes wrong.\nTo create a reliable backup of the BIOS chip(s), it's advisable to perform a triple dump of them"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"sudo flashrom -p internal -r bios_backup.rom --ifd -i bios\nsudo flashrom -p internal -r bios_backup2.rom --ifd -i bios\nsudo flashrom -p internal -r bios_backup3.rom --ifd -i bios\n"})}),"\n",(0,t.jsx)(n.p,{children:"Next, use sha1sum to compare the dumped BIOS images"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"sha1sum bios_backup.bin bios_backup2.bin bios_backup3.bin\n"})}),"\n",(0,t.jsx)(n.p,{children:"If the hashes match, you should see something like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"6cf9bfc90df1ed01336872cd159a00c101d0a7b0  bios_backup.bin\n6cf9bfc90df1ed01336872cd159a00c101d0a7b0  bios_backup2.bin\n6cf9bfc90df1ed01336872cd159a00c101d0a7b0  bios_backup3.bin\n"})}),"\n",(0,t.jsx)(n.p,{children:"Once you've confirmed that the hashes are the same, you can clean up any temporary dump files:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"rm -fr bios_backup2.bin bios_backup3.bin\n"})}),"\n",(0,t.jsx)(n.h3,{id:"step-3-patch-the-boot-script",children:"Step 3: Patch the Boot Script"}),"\n",(0,t.jsxs)(n.p,{children:["We\u2019ll modify the script so it writes ",(0,t.jsx)(n.code,{children:"0x6009"})," instead of ",(0,t.jsx)(n.code,{children:"0xE009"})," to HSFS.\nThis clears bit 15 (",(0,t.jsx)(n.code,{children:"FLOCKDN"}),"), leaving it unlocked after resume."]}),"\n",(0,t.jsx)(n.p,{children:"Run:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"sudo python chipsec_main.py -m tools.uefi.s3script_modify -a replace_op,mmio_wr,0xFED1F804,0x6009,0x2\n"})}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Output"}),(0,t.jsx)("p",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:" [*] Modifying S3 boot script entry at address 0x00000000DAF49B8F..\n [mem] 0x00000000DAF49B8F\n [*] Original entry:\n  2  0 17  2  0  0  0  1  0  0  0  4 f8 d1 fe  0 |\n  0  0  0  9 e0  4  0                            |\n [mem] buffer len = 0x17 to PA = 0x00000000DAF49B8F\n  2  0 17  2  0  0  0  1  0  0  0  4 f8 d1 fe  0 |\n  0  0  0  9 60  0  0                            |\n [mem] 0x00000000DAF49B8F\n [*] Modified entry:\n  2  0 17  2  0  0  0  1  0  0  0  4 f8 d1 fe  0 |\n  0  0  0  9 60  0  0                            | \n [*] After sleep/resume, check the value of register 0xFED1F804 is 0x6009\n [+] PASSED: The script has been modified. Go to sleep..\n"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["If successful, you\u2019ll see at the end of the logs a \u201cModified entry\u201d output with the new ",(0,t.jsx)(n.code,{children:"0x6009"})," value:"]}),"\n",(0,t.jsx)(n.h3,{id:"step-4-apply-the-patch-by-sleeping-and-resuming",children:"Step 4: Apply the Patch by Sleeping and Resuming"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Put your machine into S3 sleep (suspend)"}),"\n",(0,t.jsx)(n.li,{children:"Wake it back up"}),"\n",(0,t.jsxs)(n.li,{children:["Check if ",(0,t.jsx)(n.code,{children:"FLOCKDN"})," is now 0:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"sudo python chipsec_main.py -m common.spi_lock\n"})}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Output"}),(0,t.jsx)("p",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"...\n[x][ =======================================================================\n[x][ Module: SPI Flash Controller Configuration Locks\n[x][ =======================================================================\n[*] HSFS = 0x6008 << Hardware Sequencing Flash Status Register (SPIBAR + 0x4)\n    [00] FDONE            = 0 << Flash Cycle Done\n    [01] FCERR            = 0 << Flash Cycle Error\n    [02] AEL              = 0 << Access Error Log\n    [03] BERASE           = 1 << Block/Sector Erase Size\n    [05] SCIP             = 0 << SPI cycle in progress\n    [13] FDOPSS           = 1 << Flash Descriptor Override Pin-Strap Status\n    [14] FDV              = 1 << Flash Descriptor Valid\n    [15] FLOCKDN          = 0 << Flash Configuration Lock-Down\n[-] SPI Flash Controller configuration is not locked\n[-] FAILED: SPI Flash Controller not locked correctly.\n"})})})]}),"\n",(0,t.jsx)(n.p,{children:"If you see:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"[15] FLOCKDN = 0 << Flash Configuration Lock-Down\n"})}),"\n",(0,t.jsx)(n.p,{children:"...then it\u2019s unlocked."}),"\n",(0,t.jsx)(n.h3,{id:"step-5-remove-write-protection-from-bios-ranges",children:"Step 5: Remove Write Protection from BIOS Ranges"}),"\n",(0,t.jsxs)(n.p,{children:["Now that ",(0,t.jsx)(n.code,{children:"FLOCKDN"})," is cleared, we can disable write protection (WP) on all protected ranges:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"sudo python chipsec_util.py mmio write SPIBAR 0x74 0x4 0x0AAF0800\nsudo python chipsec_util.py mmio write SPIBAR 0x78 0x4 0x0ADE0AD0\nsudo python chipsec_util.py mmio write SPIBAR 0x7C 0x4 0x0B100B10\nsudo python chipsec_util.py mmio write SPIBAR 0x80 0x4 0x0BFF0B40\n"})}),"\n",(0,t.jsx)(n.h3,{id:"step-6-verify",children:"Step 6: Verify"}),"\n",(0,t.jsx)(n.p,{children:"Check again:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"sudo python chipsec_main.py -m common.bios_wp\n"})}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Output"}),(0,t.jsx)("p",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"[x][ =======================================================================\n[x][ Module: BIOS Region Write Protection\n[x][ =======================================================================\n[*] BC = 0x 9 << BIOS Control (b:d.f 00:31.0 + 0xDC)\n    [00] BIOSWE           = 1 << BIOS Write Enable\n    [01] BLE              = 0 << BIOS Lock Enable\n    [02] SRC              = 2 << SPI Read Configuration\n    [04] TSS              = 0 << Top Swap Status\n    [05] SMM_BWP          = 0 << SMM BIOS Write Protection\n[-] BIOS region write protection is disabled!\n\n[*] BIOS Region: Base = 0x00500000, Limit = 0x00BFFFFF\nSPI Protected Ranges\n------------------------------------------------------------\nPRx (offset) | Value    | Base     | Limit    | WP? | RP?\n------------------------------------------------------------\nPR0 (74)     | 0AAF0800 | 00800000 | 00AAF000 | 0   | 0\nPR1 (78)     | 0ADE0AD0 | 00AD0000 | 00ADE000 | 0   | 0\nPR2 (7C)     | 0B100B10 | 00B10000 | 00B10000 | 0   | 0\nPR3 (80)     | 0BFF0B40 | 00B40000 | 00BFF000 | 0   | 0\nPR4 (84)     | 00000000 | 00000000 | 00000000 | 0   | 0\n"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["If all ",(0,t.jsx)(n.code,{children:"WP?"})," values are now 0, the BIOS region is fully writable."]}),"\n",(0,t.jsx)(n.h3,{id:"step-7-flash-internally",children:"Step 7: Flash Internally"}),"\n",(0,t.jsx)(n.p,{children:"You can now flash Coreboot or a modified BIOS:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"sudo flashrom -p internal -w coreboot.rom --ifd -i bios -N\n"})}),"\n",(0,t.jsx)(n.admonition,{title:"Important",type:"danger",children:(0,t.jsx)(n.p,{children:"Only flash the BIOS region (--ifd -i bios). The FD and ME regions are still locked."})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var i=s(6540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);