"use strict";(globalThis.webpackChunkmy_personal_website=globalThis.webpackChunkmy_personal_website||[]).push([[5282],{502(e,s,t){t.r(s),t.d(s,{assets:()=>N,contentTitle:()=>A,default:()=>C,frontMatter:()=>D,metadata:()=>r,toc:()=>V});const r=JSON.parse('{"id":"basics/keys/derivation-path","title":"Derivation Path","description":"Practical guide: Derivation Path. Covers The BIP32 Standard, Anatomy of a Derivation Path, Common Derivation Paths.","source":"@site/docs/basics/keys/derivation-path.mdx","sourceDirName":"basics/keys","slug":"/basics/keys/derivation-path","permalink":"/docs/basics/keys/derivation-path","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"private keys","permalink":"/docs/tags/private-keys"},{"inline":true,"label":"derivation path","permalink":"/docs/tags/derivation-path"},{"inline":true,"label":"bip39","permalink":"/docs/tags/bip-39"},{"inline":true,"label":"seed","permalink":"/docs/tags/seed"}],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Derivation Path","description":"Practical guide: Derivation Path. Covers The BIP32 Standard, Anatomy of a Derivation Path, Common Derivation Paths.","keywords":["bitcoin","self custody","security","privacy","basics","derivation","path"],"tags":["private keys","derivation path","bip39","seed"]},"sidebar":"tutorialBasics","previous":{"title":"Passphrase","permalink":"/docs/basics/keys/passphrase"},"next":{"title":"Extended Private Key (XPRV)","permalink":"/docs/basics/keys/xprv"}}');var i=t(4848),n=t(8453),a=t(6540),l=t(8215),o=t(7559),c=t(3104),d=t(6347),h=t(205),u=t(7485),p=t(1682),x=t(679);function f(e){return a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:s}=e;return!!s&&"object"==typeof s&&"value"in s}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function v(e){const{values:s,children:t}=e;return(0,a.useMemo)(()=>{const e=s??function(e){return f(e).map(({props:{value:e,label:s,attributes:t,default:r}})=>({value:e,label:s,attributes:t,default:r}))}(t);return function(e){const s=(0,p.XI)(e,(e,s)=>e.value===s.value);if(s.length>0)throw new Error(`Docusaurus error: Duplicate values "${s.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[s,t])}function m({value:e,tabValues:s}){return s.some(s=>s.value===e)}function j({queryString:e=!1,groupId:s}){const t=(0,d.W6)(),r=function({queryString:e=!1,groupId:s}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!s)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return s??null}({queryString:e,groupId:s});return[(0,u.aZ)(r),(0,a.useCallback)(e=>{if(!r)return;const s=new URLSearchParams(t.location.search);s.set(r,e),t.replace({...t.location,search:s.toString()})},[r,t])]}function b(e){const{defaultValue:s,queryString:t=!1,groupId:r}=e,i=v(e),[n,l]=(0,a.useState)(()=>function({defaultValue:e,tabValues:s}){if(0===s.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:s}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${s.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=s.find(e=>e.default)??s[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:s,tabValues:i})),[o,c]=j({queryString:t,groupId:r}),[d,u]=function({groupId:e}){const s=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,r]=(0,x.Dv)(s);return[t,(0,a.useCallback)(e=>{s&&r.set(e)},[s,r])]}({groupId:r}),p=(()=>{const e=o??d;return m({value:e,tabValues:i})?e:null})();(0,h.A)(()=>{p&&l(p)},[p]);return{selectedValue:n,selectValue:(0,a.useCallback)(e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),c(e),u(e)},[c,u,i]),tabValues:i}}var g=t(2303);const y="tabList__CuJ",w="tabItem_LNqP";function P({className:e,block:s,selectedValue:t,selectValue:r,tabValues:n}){const a=[],{blockElementScrollPositionUntilNextRender:o}=(0,c.a_)(),d=e=>{const s=e.currentTarget,i=a.indexOf(s),l=n[i].value;l!==t&&(o(s),r(l))},h=e=>{let s=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=a.indexOf(e.currentTarget)+1;s=a[t]??a[0];break}case"ArrowLeft":{const t=a.indexOf(e.currentTarget)-1;s=a[t]??a[a.length-1];break}}s?.focus()};return(0,i.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.A)("tabs",{"tabs--block":s},e),children:n.map(({value:e,label:s,attributes:r})=>(0,i.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{a.push(e)},onKeyDown:h,onClick:d,...r,className:(0,l.A)("tabs__item",w,r?.className,{"tabs__item--active":t===e}),children:s??e},e))})}function T({lazy:e,children:s,selectedValue:t}){const r=(Array.isArray(s)?s:[s]).filter(Boolean);if(e){const e=r.find(e=>e.props.value===t);return e?(0,a.cloneElement)(e,{className:(0,l.A)("margin-top--md",e.props.className)}):null}return(0,i.jsx)("div",{className:"margin-top--md",children:r.map((e,s)=>(0,a.cloneElement)(e,{key:s,hidden:e.props.value!==t}))})}function k(e){const s=b(e);return(0,i.jsxs)("div",{className:(0,l.A)(o.G.tabs.container,"tabs-container",y),children:[(0,i.jsx)(P,{...s,...e}),(0,i.jsx)(T,{...s,...e})]})}function S(e){const s=(0,g.A)();return(0,i.jsx)(k,{...e,children:f(e.children)},String(s))}const I="tabItem_Ymn6";function B({children:e,hidden:s,className:t}){return(0,i.jsx)("div",{role:"tabpanel",className:(0,l.A)(I,t),hidden:s,children:e})}const D={sidebar_position:6,title:"Derivation Path",description:"Practical guide: Derivation Path. Covers The BIP32 Standard, Anatomy of a Derivation Path, Common Derivation Paths.",keywords:["bitcoin","self custody","security","privacy","basics","derivation","path"],tags:["private keys","derivation path","bip39","seed"]},A="Derivation Path",N={},V=[{value:"The BIP32 Standard",id:"the-bip32-standard",level:2},{value:"Anatomy of a Derivation Path",id:"anatomy-of-a-derivation-path",level:2},{value:"Common Derivation Paths",id:"common-derivation-paths",level:2},{value:"BIP-44 (Universal Path for Multiple Coins)",id:"bip-44-universal-path-for-multiple-coins",level:4},{value:"BIP-49 (Pay-to-Script-Hash with SegWit)",id:"bip-49-pay-to-script-hash-with-segwit",level:4},{value:"BIP-84 (Native SegWit with Bech32)",id:"bip-84-native-segwit-with-bech32",level:4},{value:"BIP-86 (Taproot with Bech32m)",id:"bip-86-taproot-with-bech32m",level:4}];function q(e){const s={code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"derivation-path",children:"Derivation Path"})}),"\n",(0,i.jsx)(s.p,{children:"A derivation path determines how your private keys are derived from your seed phrase and which addresses are generated from those keys."}),"\n",(0,i.jsx)(s.h2,{id:"the-bip32-standard",children:"The BIP32 Standard"}),"\n",(0,i.jsx)(s.p,{children:"The BIP32 (Bitcoin Improvement Proposal) standard defines how hierarchical deterministic (HD) wallets work. HD wallets use a tree-like structure where every branch can produce a new keypair (private and public key). This means you only need to back up the seed phrase, and the wallet can regenerate all keys and addresses from that phrase."}),"\n",(0,i.jsx)(s.h2,{id:"anatomy-of-a-derivation-path",children:"Anatomy of a Derivation Path"}),"\n",(0,i.jsx)(s.p,{children:"A typical derivation path looks like this:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"m / 44' / 0' / 0' / 0 / 0\n"})}),"\n",(0,i.jsx)(s.p,{children:"Here\u2019s what each part means:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"m"})," - The master node (your seed phrase). This is the root of the tree."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"44'"})," - The purpose or protocol. The apostrophe ('), known as the hardened separator, indicates that these keys are hardened for security."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0'"})," - The coin type. ",(0,i.jsx)(s.strong,{children:"For Bitcoin, this is always 0"})," (but for other cryptocurrencies, it would be a different number)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0'"})," - The account. A wallet can have multiple accounts, each with its own address."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0"})," - The change type (0 for external addresses, 1 for internal addresses like change)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0"})," - The address index. This is used to generate a new address each time."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"common-derivation-paths",children:"Common Derivation Paths"}),"\n",(0,i.jsx)(s.p,{children:"Here are some of the most common derivation paths used in Bitcoin wallets:"}),"\n",(0,i.jsxs)(S,{queryString:"derivation-path",children:[(0,i.jsxs)(B,{value:"bip44",label:"BIP44",children:[(0,i.jsx)(s.h4,{id:"bip-44-universal-path-for-multiple-coins",children:"BIP-44 (Universal Path for Multiple Coins)"}),(0,i.jsx)(s.p,{children:"BIP-44 is the most widely used standard for creating wallets that manage multiple cryptocurrencies. It\u2019s designed to support multi-asset wallets and has a clear, structured path for generating different addresses."}),(0,i.jsx)(s.p,{children:"Standard Path:"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"m / 44' / 0' / 0' / 0 / 0\n"})}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"44'"}),": Indicates the wallet follows BIP-44 for multi-asset support."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0'"}),": This specifies the Bitcoin coin type."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0'"}),": Refers to the first account in the wallet."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0"}),": The external addresses (i.e., the ones used to receive funds)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0"}),": The first address in the external address list."]}),"\n"]}),(0,i.jsxs)(s.p,{children:["Addresses starts with ",(0,i.jsx)(s.code,{children:"1"}),":"]}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"137oszRjc8tdUVWr5nSp6fzSND938PStMZ\n"})})]}),(0,i.jsxs)(B,{value:"bip49",label:"BIP49",children:[(0,i.jsx)(s.h4,{id:"bip-49-pay-to-script-hash-with-segwit",children:"BIP-49 (Pay-to-Script-Hash with SegWit)"}),(0,i.jsx)(s.p,{children:"BIP-49 defines a path for creating P2SH (Pay-to-Script-Hash) addresses, a type of Bitcoin address that begins with 3. This path is used for SegWit transactions, improving transaction efficiency and lowering fees."}),(0,i.jsx)(s.p,{children:"Standard Path:"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"m / 49' / 0' / 0' / 0 / 0\n"})}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"49'"}),": Indicates SegWit addresses that start with 3 (P2SH)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0'"}),": Specifies Bitcoin as the coin type."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0'"}),": Refers to the first account."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0"}),": External addresses."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0"}),": The first address for receiving."]}),"\n"]}),(0,i.jsxs)(s.p,{children:["Addresses starts with ",(0,i.jsx)(s.code,{children:"3"}),":"]}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"33S43b6qmVHVTjwp75M7XoTTPEvKVh8zqH\n"})})]}),(0,i.jsxs)(B,{value:"bip84",label:"BIP84",children:[(0,i.jsx)(s.h4,{id:"bip-84-native-segwit-with-bech32",children:"BIP-84 (Native SegWit with Bech32)"}),(0,i.jsx)(s.p,{children:"BIP-84 is used to generate native SegWit addresses, which start with bc1q and are more efficient than older types of Bitcoin addresses. These addresses have a lower transaction fee and are fully compatible with the SegWit protocol."}),(0,i.jsx)(s.p,{children:"Standard Path:"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"m / 84' / 0' / 0' / 0 / 0\n"})}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"84'"}),": Specifies ",(0,i.jsx)(s.strong,{children:"native SegWit"})," addresses (starting with bc1q)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0'"}),": The coin type for Bitcoin."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0'"}),": The first account."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0"}),": External addresses."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0"}),": The first address."]}),"\n"]}),(0,i.jsxs)(s.p,{children:["Addresses starts with ",(0,i.jsx)(s.code,{children:"bc1"}),":"]}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"bc1q6khgephuq2hyvrn49zrvsxztmtjg4ze7sxkpp4\n"})})]}),(0,i.jsxs)(B,{value:"bip86",label:"BIP86",children:[(0,i.jsx)(s.h4,{id:"bip-86-taproot-with-bech32m",children:"BIP-86 (Taproot with Bech32m)"}),(0,i.jsxs)(s.p,{children:["BIP-86 is used to generate Taproot addresses, which start with ",(0,i.jsx)(s.code,{children:"bc1p"}),". These addresses improve privacy and efficiency by leveraging Schnorr signatures and Merkelized Abstract Syntax Trees (MAST)."]}),(0,i.jsx)(s.p,{children:"Standard Path:"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"m / 86' / 0' / 0' / 0 / 0\n"})}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"86'"}),": Specifies ",(0,i.jsx)(s.strong,{children:"Taproot"})," addresses (starting with bc1p)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0'"}),": The coin type for Bitcoin."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0'"}),": The first account."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0"}),": External addresses."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"0"}),": The first address."]}),"\n"]}),(0,i.jsxs)(s.p,{children:["Addresses start with ",(0,i.jsx)(s.code,{children:"bc1p"}),":"]}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"bc1ps3yjzpnxeg9yx43f9zmrl9njhvlwh4pm5peuu5ucqqp7f4362cvqeesncf\n"})})]})]})]})}function C(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(q,{...e})}):q(e)}},8453(e,s,t){t.d(s,{R:()=>a,x:()=>l});var r=t(6540);const i={},n=r.createContext(i);function a(e){const s=r.useContext(n);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(n.Provider,{value:s},e.children)}}}]);