"use strict";(self.webpackChunkmy_personal_website=self.webpackChunkmy_personal_website||[]).push([[4616],{7133:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>V,contentTitle:()=>B,default:()=>D,frontMatter:()=>S,metadata:()=>r,toc:()=>N});const r=JSON.parse('{"id":"basics/private-keys/derivation-path","title":"Derivation Path","description":"A derivation path determines how your private keys are derived from your seed phrase and which addresses are generated from those keys.","source":"@site/docs/basics/private-keys/derivation-path.mdx","sourceDirName":"basics/private-keys","slug":"/basics/private-keys/derivation-path","permalink":"/docs/basics/private-keys/derivation-path","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"private keys","permalink":"/docs/tags/private-keys"},{"inline":true,"label":"derivation path","permalink":"/docs/tags/derivation-path"},{"inline":true,"label":"bip39","permalink":"/docs/tags/bip-39"},{"inline":true,"label":"seed","permalink":"/docs/tags/seed"}],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Derivation Path","slug":"/basics/private-keys/derivation-path","tags":["private keys","derivation path","bip39","seed"]},"sidebar":"tutorialBasics","previous":{"title":"Conversion to BIP39","permalink":"/docs/basics/private-keys/bip39"},"next":{"title":"Extended Private Key (XPRV)","permalink":"/docs/basics/private-keys/xprv"}}');var a=s(4848),n=s(8453),i=s(6540),l=s(8215),o=s(5627),c=s(6347),d=s(372),h=s(604),u=s(1861),p=s(8749);function x(e){return i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function f(e){const{values:t,children:s}=e;return(0,i.useMemo)((()=>{const e=t??function(e){return x(e).map((e=>{let{props:{value:t,label:s,attributes:r,default:a}}=e;return{value:t,label:s,attributes:r,default:a}}))}(s);return function(e){const t=(0,u.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,s])}function v(e){let{value:t,tabValues:s}=e;return s.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:s}=e;const r=(0,c.W6)(),a=function(e){let{queryString:t=!1,groupId:s}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!s)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return s??null}({queryString:t,groupId:s});return[(0,h.aZ)(a),(0,i.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(r.location.search);t.set(a,e),r.replace({...r.location,search:t.toString()})}),[a,r])]}function b(e){const{defaultValue:t,queryString:s=!1,groupId:r}=e,a=f(e),[n,l]=(0,i.useState)((()=>function(e){let{defaultValue:t,tabValues:s}=e;if(0===s.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!v({value:t,tabValues:s}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${s.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=s.find((e=>e.default))??s[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:a}))),[o,c]=m({queryString:s,groupId:r}),[h,u]=function(e){let{groupId:t}=e;const s=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,a]=(0,p.Dv)(s);return[r,(0,i.useCallback)((e=>{s&&a.set(e)}),[s,a])]}({groupId:r}),x=(()=>{const e=o??h;return v({value:e,tabValues:a})?e:null})();(0,d.A)((()=>{x&&l(x)}),[x]);return{selectedValue:n,selectValue:(0,i.useCallback)((e=>{if(!v({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);l(e),c(e),u(e)}),[c,u,a]),tabValues:a}}var j=s(9136);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function y(e){let{className:t,block:s,selectedValue:r,selectValue:n,tabValues:i}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,o.a_)(),h=e=>{const t=e.currentTarget,s=c.indexOf(t),a=i[s].value;a!==r&&(d(t),n(a))},u=e=>{let t=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{const s=c.indexOf(e.currentTarget)+1;t=c[s]??c[0];break}case"ArrowLeft":{const s=c.indexOf(e.currentTarget)-1;t=c[s]??c[c.length-1];break}}t?.focus()};return(0,a.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.A)("tabs",{"tabs--block":s},t),children:i.map((e=>{let{value:t,label:s,attributes:n}=e;return(0,a.jsx)("li",{role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,ref:e=>{c.push(e)},onKeyDown:u,onClick:h,...n,className:(0,l.A)("tabs__item",g.tabItem,n?.className,{"tabs__item--active":r===t}),children:s??t},t)}))})}function w(e){let{lazy:t,children:s,selectedValue:r}=e;const n=(Array.isArray(s)?s:[s]).filter(Boolean);if(t){const e=n.find((e=>e.props.value===r));return e?(0,i.cloneElement)(e,{className:(0,l.A)("margin-top--md",e.props.className)}):null}return(0,a.jsx)("div",{className:"margin-top--md",children:n.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==r})))})}function k(e){const t=b(e);return(0,a.jsxs)("div",{className:(0,l.A)("tabs-container",g.tabList),children:[(0,a.jsx)(y,{...t,...e}),(0,a.jsx)(w,{...t,...e})]})}function P(e){const t=(0,j.A)();return(0,a.jsx)(k,{...e,children:x(e.children)},String(t))}const I={tabItem:"tabItem_Ymn6"};function T(e){let{children:t,hidden:s,className:r}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,l.A)(I.tabItem,r),hidden:s,children:t})}const S={sidebar_position:5,title:"Derivation Path",slug:"/basics/private-keys/derivation-path",tags:["private keys","derivation path","bip39","seed"]},B="Derivation Path",V={},N=[{value:"The BIP32 Standard",id:"the-bip32-standard",level:2},{value:"Anatomy of a Derivation Path",id:"anatomy-of-a-derivation-path",level:2},{value:"Common Derivation Paths",id:"common-derivation-paths",level:2},{value:"BIP-44 (Universal Path for Multiple Coins)",id:"bip-44-universal-path-for-multiple-coins",level:4},{value:"BIP-49 (Pay-to-Script-Hash with SegWit)",id:"bip-49-pay-to-script-hash-with-segwit",level:4},{value:"BIP-84 (Native SegWit with Bech32)",id:"bip-84-native-segwit-with-bech32",level:4}];function A(e){const t={code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"derivation-path",children:"Derivation Path"})}),"\n",(0,a.jsx)(t.p,{children:"A derivation path determines how your private keys are derived from your seed phrase and which addresses are generated from those keys."}),"\n",(0,a.jsx)(t.h2,{id:"the-bip32-standard",children:"The BIP32 Standard"}),"\n",(0,a.jsx)(t.p,{children:"The BIP32 (Bitcoin Improvement Proposal) standard defines how hierarchical deterministic (HD) wallets work. HD wallets use a tree-like structure where every branch can produce a new keypair (private and public key). This means you only need to back up the seed phrase, and the wallet can regenerate all keys and addresses from that phrase."}),"\n",(0,a.jsx)(t.h2,{id:"anatomy-of-a-derivation-path",children:"Anatomy of a Derivation Path"}),"\n",(0,a.jsx)(t.p,{children:"A typical derivation path looks like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"m / 44' / 0' / 0' / 0 / 0\n"})}),"\n",(0,a.jsx)(t.p,{children:"Here\u2019s what each part means:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"m"})," - The master node (your seed phrase). This is the root of the tree."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"44'"})," - The purpose or protocol. The apostrophe ('), known as the hardened separator, indicates that these keys are hardened for security."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0'"})," - The coin type. ",(0,a.jsx)(t.strong,{children:"For Bitcoin, this is always 0"})," (but for other cryptocurrencies, it would be a different number)."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0'"})," - The account. A wallet can have multiple accounts, each with its own address."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0"})," - The change type (0 for external addresses, 1 for internal addresses like change)."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0"})," - The address index. This is used to generate a new address each time."]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"common-derivation-paths",children:"Common Derivation Paths"}),"\n",(0,a.jsx)(t.p,{children:"Here are some of the most common derivation paths used in Bitcoin wallets:"}),"\n",(0,a.jsxs)(P,{queryString:"derivation-path",children:[(0,a.jsxs)(T,{value:"bip44",label:"BIP44",children:[(0,a.jsx)(t.h4,{id:"bip-44-universal-path-for-multiple-coins",children:"BIP-44 (Universal Path for Multiple Coins)"}),(0,a.jsx)(t.p,{children:"BIP-44 is the most widely used standard for creating wallets that manage multiple cryptocurrencies. It\u2019s designed to support multi-asset wallets and has a clear, structured path for generating different addresses."}),(0,a.jsx)(t.p,{children:"Standard Path:"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"m / 44' / 0' / 0' / 0 / 0\n"})}),(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"44'"}),": Indicates the wallet follows BIP-44 for multi-asset support."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0'"}),": This specifies the Bitcoin coin type."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0'"}),": Refers to the first account in the wallet."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0"}),": The external addresses (i.e., the ones used to receive funds)."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0"}),": The first address in the external address list."]}),"\n"]}),(0,a.jsxs)(t.p,{children:["Addresses starts with ",(0,a.jsx)(t.code,{children:"1"}),":"]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"137oszRjc8tdUVWr5nSp6fzSND938PStMZ\n"})})]}),(0,a.jsxs)(T,{value:"bip49",label:"BIP49",children:[(0,a.jsx)(t.h4,{id:"bip-49-pay-to-script-hash-with-segwit",children:"BIP-49 (Pay-to-Script-Hash with SegWit)"}),(0,a.jsx)(t.p,{children:"BIP-49 defines a path for creating P2SH (Pay-to-Script-Hash) addresses, a type of Bitcoin address that begins with 3. This path is used for SegWit transactions, improving transaction efficiency and lowering fees."}),(0,a.jsx)(t.p,{children:"Standard Path:"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"m / 49' / 0' / 0' / 0 / 0\n"})}),(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"49'"}),": Indicates SegWit addresses that start with 3 (P2SH)."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0'"}),": Specifies Bitcoin as the coin type."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0'"}),": Refers to the first account."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0"}),": External addresses."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0"}),": The first address for receiving."]}),"\n"]}),(0,a.jsxs)(t.p,{children:["Addresses starts with ",(0,a.jsx)(t.code,{children:"3"}),":"]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"33S43b6qmVHVTjwp75M7XoTTPEvKVh8zqH\n"})})]}),(0,a.jsxs)(T,{value:"bip84",label:"BIP84",children:[(0,a.jsx)(t.h4,{id:"bip-84-native-segwit-with-bech32",children:"BIP-84 (Native SegWit with Bech32)"}),(0,a.jsx)(t.p,{children:"BIP-84 is used to generate native SegWit addresses, which start with bc1q and are more efficient than older types of Bitcoin addresses. These addresses have a lower transaction fee and are fully compatible with the SegWit protocol."}),(0,a.jsx)(t.p,{children:"Standard Path:"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"m / 84' / 0' / 0' / 0 / 0\n"})}),(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"84'"}),": Specifies ",(0,a.jsx)(t.strong,{children:"native SegWit"})," addresses (starting with bc1q)."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0'"}),": The coin type for Bitcoin."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0'"}),": The first account."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0"}),": External addresses."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"0"}),": The first address."]}),"\n"]}),(0,a.jsxs)(t.p,{children:["Addresses starts with ",(0,a.jsx)(t.code,{children:"bc1"}),":"]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"bc1q6khgephuq2hyvrn49zrvsxztmtjg4ze7sxkpp4\n"})})]})]})]})}function D(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(A,{...e})}):A(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>l});var r=s(6540);const a={},n=r.createContext(a);function i(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);