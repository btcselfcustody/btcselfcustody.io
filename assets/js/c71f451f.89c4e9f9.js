"use strict";(self.webpackChunkmy_personal_website=self.webpackChunkmy_personal_website||[]).push([[5500],{1114:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"coreboot/external-flashing","title":"External Flashing","description":"External flashing is sometimes necessary instead of internal flashing. The main reasons are:","source":"@site/docs/coreboot/external-flashing.mdx","sourceDirName":"coreboot","slug":"/coreboot/external-flashing/","permalink":"/docs/coreboot/external-flashing/","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"coreboot","permalink":"/docs/tags/coreboot"},{"inline":true,"label":"chipsec","permalink":"/docs/tags/chipsec"},{"inline":true,"label":"bios","permalink":"/docs/tags/bios"},{"inline":true,"label":"external","permalink":"/docs/tags/external"},{"inline":true,"label":"flashing","permalink":"/docs/tags/flashing"}],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"External Flashing","slug":"/coreboot/external-flashing/","tags":["coreboot","chipsec","bios","external","flashing"]},"sidebar":"tutorialCoreboot","previous":{"title":"Flashing","permalink":"/docs/coreboot/internal/flashing"}}');var o=t(4848),a=t(8453),i=t(1662);const s={sidebar_position:5,title:"External Flashing",slug:"/coreboot/external-flashing/",tags:["coreboot","chipsec","bios","external","flashing"]},l="External Flashing",c={},d=[{value:"Detect the Chip",id:"detect-the-chip",level:2},{value:"Backup the Factory Bios",id:"backup-the-factory-bios",level:2},{value:"Neutralize Intel ME",id:"neutralize-intel-me",level:2},{value:"Flash the Neutralized Intel ME",id:"flash-the-neutralized-intel-me",level:2},{value:"Flash the Coreboot BIOS Region",id:"flash-the-coreboot-bios-region",level:2},{value:"Verify Intel ME Neutralization",id:"verify-intel-me-neutralization",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"external-flashing",children:"External Flashing"})}),"\n",(0,o.jsx)(n.p,{children:"External flashing is sometimes necessary instead of internal flashing. The main reasons are:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Neutralizing Intel ME"}),": Internal flashing can\u2019t access the ME region on stock firmware, so an external flash is required the first time if you want to disable or neutralize Intel ME."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Recovery"}),": If an internal flash fails and the laptop no longer boots, an external programmer is the only way to restore the system."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Hardware restrictions"}),": Some motherboards simply don\u2019t allow internal flashing at all, so external flashing is the only option."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"detect-the-chip",children:"Detect the Chip"}),"\n",(0,o.jsx)(n.p,{children:"Now, you need to detect the chip model using flashrom. To ensure accurate detection, follow these steps for the BIOS chip:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Based on your BIOS Chip type (",(0,o.jsx)(n.code,{children:"SOIC"})," or ",(0,o.jsx)(n.code,{children:"WSON"}),") Connect the Raspberry Pico to your Pomona Clip (1st photo) or Pogo Pin Adapter (2nd photo) using Dupont cables, as showed in Libreboot guide."]}),"\n",(0,o.jsx)(n.li,{children:"Attach the clip firmly onto the BIOS chip, ensuring proper contact with all pins"}),"\n",(0,o.jsx)(n.li,{children:"Plug the Raspberry Pico into the laptop using a USB cable"}),"\n"]}),"\n","\n",(0,o.jsxs)(i.Ay,{container:!0,spacing:2,children:[(0,o.jsx)(i.Ay,{item:!0,xs:12,sm:6,md:6,style:{textAlign:"center"},children:(0,o.jsx)("img",{src:"/img/libreboot/connection.jpg",alt:"Connection Setup",style:{width:"100%",maxWidth:"100%"}})}),(0,o.jsx)(i.Ay,{item:!0,xs:12,sm:6,md:6,style:{textAlign:"center"},children:(0,o.jsx)("img",{src:"/img/coreboot/connection.jpg",alt:"Connection Clip",style:{width:"100%",maxWidth:"100%"}})})]}),"\n",(0,o.jsx)(n.p,{children:"Execute the following command to detect the chip"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"sudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M\n"})}),"\n",(0,o.jsx)(n.p,{children:"If multiple chips are detected, identify the correct BIOS chip based on prior photos or markings. Subsequently, re-run the command, making sure to specify the name of the pertinent chip."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'sudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V"\n'})}),"\n",(0,o.jsx)(n.p,{children:"If the Raspberry Pico detects the chip, you may proceed by creating a backup."}),"\n",(0,o.jsx)(n.h2,{id:"backup-the-factory-bios",children:"Backup the Factory Bios"}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsx)(n.p,{children:"If you are coming from a unsuccessful internal flashing, you can skip this part as there is no point to dump a bios that does not work."})}),"\n",(0,o.jsx)(n.p,{children:"To create a reliable backup of the BIOS chip(s), it's advisable to perform a triple dump of them"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'sudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V" -r factory.bin\nsudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V" -r factory2.bin\nsudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V" -r factory3.bin\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Next, use ",(0,o.jsx)(n.code,{children:"sha1sum"})," to compare the dumped BIOS images"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"sha1sum factory.bin factory2.bin factory3.bin\n"})}),"\n",(0,o.jsx)(n.p,{children:"If the hashes match, you should see something like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"6cf9bfc90df1ed01336872cd159a00c101d0a7b0  factory.bin\n6cf9bfc90df1ed01336872cd159a00c101d0a7b0  factory2.bin\n6cf9bfc90df1ed01336872cd159a00c101d0a7b0  factory3.bin\n"})}),"\n",(0,o.jsx)(n.p,{children:"Once you've confirmed that the hashes are the same, you can clean up any temporary dump files:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"rm -fr factory2.bin factory3.bin\n"})}),"\n",(0,o.jsx)(n.h2,{id:"neutralize-intel-me",children:"Neutralize Intel ME"}),"\n",(0,o.jsxs)(n.p,{children:["Check if the dumped image has the correct structure by using ",(0,o.jsx)(n.code,{children:"ifdtool"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"cd coreboot/util/ifdtool\nmake\n./ifdtool -d factory.bin\n"})}),"\n",(0,o.jsx)(n.p,{children:"It should print a long output, including the section related to Intel ME:"}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Output"}),(0,o.jsx)("p",{children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:"Warning: No platform specified. Output may be incomplete\nFile t430s_full_dump_coreboot.bin is 16777216 bytes\nPCH Revision: 6 series Cougar Point\nFLMAP0:    0x03040003\n  NR:      3\n  FRBA:    0x40\n  NC:      1\n  FCBA:    0x30\nFLMAP1:    0x12100206\n  ISL:     0x12\n  FPSBA:   0x100\n  NM:      2\n  FMBA:    0x60\nFLMAP2:    0x00210120\n  PSL:     0x2101\n  FMSBA:   0x200\nFLUMAP1:   0x000018df\n  Intel ME VSCC Table Length (VTL):        24\n  Intel ME VSCC Table Base Address (VTBA): 0x000df0\n\nME VSCC table:\n  JID0:  0x001620c2\n    SPI Component Vendor ID:            0xc2\n    SPI Component Device ID 0:          0x20\n    SPI Component Device ID 1:          0x16\n  VSCC0: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n  JID1:  0x001720c2\n    SPI Component Vendor ID:            0xc2\n    SPI Component Device ID 0:          0x20\n    SPI Component Device ID 1:          0x17\n  VSCC1: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n  JID2:  0x001820c2\n    SPI Component Vendor ID:            0xc2\n    SPI Component Device ID 0:          0x20\n    SPI Component Device ID 1:          0x18\n  VSCC2: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n  JID3:  0x001640ef\n    SPI Component Vendor ID:            0xef\n    SPI Component Device ID 0:          0x40\n    SPI Component Device ID 1:          0x16\n  VSCC3: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n  JID4:  0x001740ef\n    SPI Component Vendor ID:            0xef\n    SPI Component Device ID 0:          0x40\n    SPI Component Device ID 1:          0x17\n  VSCC4: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n  JID5:  0x001840ef\n    SPI Component Vendor ID:            0xef\n    SPI Component Device ID 0:          0x40\n    SPI Component Device ID 1:          0x18\n  VSCC5: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n  JID6:  0x0016ba20\n    SPI Component Vendor ID:            0x20\n    SPI Component Device ID 0:          0xba\n    SPI Component Device ID 1:          0x16\n  VSCC6: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n  JID7:  0x0017ba20\n    SPI Component Vendor ID:            0x20\n    SPI Component Device ID 0:          0xba\n    SPI Component Device ID 1:          0x17\n  VSCC7: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n\nOEM Section:\n00: 47 31 52 4e 31 36 57 57 ff 38 2e 31 2e 34 30 2e\n10: 31 34 31 36 ff 31 36 4d 42 ff 53 49 47 4e 45 44\n20: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n30: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n\nFound Region Section\nFLREG0:    0x00000000\n  Flash Region 0 (Flash Descriptor): 00000000 - 00000fff \nFLREG1:    0x0fff0500\n  Flash Region 1 (BIOS): 00500000 - 00ffffff \nFLREG2:    0x04ff0003\n  Flash Region 2 (Intel ME): 00003000 - 004fffff \nFLREG3:    0x00020001\n  Flash Region 3 (GbE): 00001000 - 00002fff \nFLREG4:    0x00001fff\n  Flash Region 4 (Platform Data): 00fff000 - 00000fff (unused)\n\nFound Component Section\nFLCOMP     0x4990001d\n  Dual Output Fast Read Support:       supported\n  Read ID/Read Status Clock Frequency: 33MHz\n  Write/Erase Clock Frequency:         33MHz\n  Fast Read Clock Frequency:           50MHz\n  Fast Read Support:                   supported\n  Read Clock Frequency:                20MHz\n  Component 2 Density:                 4MB\n  Component 1 Density:                 16MB\nFLILL      0x00000000\n  Invalid Instruction 3: 0x00\n  Invalid Instruction 2: 0x00\n  Invalid Instruction 1: 0x00\n  Invalid Instruction 0: 0x00\nFLPB       0x00000000\n  Flash Partition Boundary Address: 0x000000\n\nFound PCH Strap Section\nPCHSTRP0  : 0x4810d782\nPCHSTRP1  : 0x0000010f\nPCHSTRP2  : 0x00000000\nPCHSTRP3  : 0x00000000\nPCHSTRP4  : 0x00c8e102\nPCHSTRP5  : 0x00000000\nPCHSTRP6  : 0x00000000\nPCHSTRP7  : 0x00000000\nPCHSTRP8  : 0x00000000\nPCHSTRP9  : 0x30000b8c\nPCHSTRP10 : 0x00410044\nPCHSTRP11 : 0x99000097\nPCHSTRP12 : 0x00000000\nPCHSTRP13 : 0x00000000\nPCHSTRP14 : 0x00000000\nPCHSTRP15 : 0x0000437e\nPCHSTRP16 : 0x00000000\nPCHSTRP17 : 0x00000002\nAltMeDisable bit is not set\n\nFound Master Section\nFLMSTR1:   0x0a0b0000 (Host CPU/BIOS)\n  Platform Data Region Write Access: disabled\n  GbE Region Write Access:           enabled\n  Intel ME Region Write Access:      disabled\n  Host CPU/BIOS Region Write Access: enabled\n  Flash Descriptor Write Access:     disabled\n  Platform Data Region Read Access:  disabled\n  GbE Region Read Access:            enabled\n  Intel ME Region Read Access:       disabled\n  Host CPU/BIOS Region Read Access:  enabled\n  Flash Descriptor Read Access:      enabled\n  Requester ID:                      0x0000\n\nFLMSTR2:   0x0c0d0000 (Intel ME)\n  Platform Data Region Write Access: disabled\n  GbE Region Write Access:           enabled\n  Intel ME Region Write Access:      enabled\n  Host CPU/BIOS Region Write Access: disabled\n  Flash Descriptor Write Access:     disabled\n  Platform Data Region Read Access:  disabled\n  GbE Region Read Access:            enabled\n  Intel ME Region Read Access:       enabled\n  Host CPU/BIOS Region Read Access:  disabled\n  Flash Descriptor Read Access:      enabled\n  Requester ID:                      0x0000\n\nFLMSTR3:   0x08080118 (GbE)\n  Platform Data Region Write Access: disabled\n  GbE Region Write Access:           enabled\n  Intel ME Region Write Access:      disabled\n  Host CPU/BIOS Region Write Access: disabled\n  Flash Descriptor Write Access:     disabled\n  Platform Data Region Read Access:  disabled\n  GbE Region Read Access:            enabled\n  Intel ME Region Read Access:       disabled\n  Host CPU/BIOS Region Read Access:  disabled\n  Flash Descriptor Read Access:      disabled\n  Requester ID:                      0x0118\n\nFound Processor Strap Section\n????:      0x00000000\n????:      0xffffffff\n????:      0xffffffff\n????:      0xffffffff\n????:      0xffffffff\n????:      0xffffffff\n????:      0xffffffff\n????:      0xffffffff\n"})})})]}),"\n",(0,o.jsx)(n.p,{children:"Now to check if the dumped ME image is valid just run:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"python me_cleaner.py -c factory.bin\n"})}),"\n",(0,o.jsx)(n.p,{children:"You should get an output like the one below:"}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Output"}),(0,o.jsx)("p",{children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:"Full image detected\nThe ME/TXE region goes from 0x3000 to 0x500000\nFound FPT header at 0x3010\nFound 23 partition(s)\nFound FTPR header: FTPR partition spans from 0x180000 to 0x24a000\nME/TXE firmware version 8.1.40.1416\nPublic key match: Intel ME, firmware versions 7.x.x.x, 8.x.x.x\nThe AltMeDisable bit is NOT SET\nChecking the FTPR RSA signature... VALID\n"})})})]}),"\n",(0,o.jsxs)(n.p,{children:["Apply ",(0,o.jsx)(n.code,{children:"me_cleaner"})]}),"\n",(0,o.jsxs)(n.p,{children:["To neutralize Intel ME you can just use ",(0,o.jsx)(n.code,{children:"me_cleaner"})," on it:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"python me_cleaner.py -S -O factory_me_neutralized.bin factory.bin\n"})}),"\n",(0,o.jsx)(n.p,{children:"You should get an output like the one below:"}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Output"}),(0,o.jsx)("p",{children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:"Full image detected\nThe ME/TXE region goes from 0x3000 to 0x500000\nFound FPT header at 0x3010\nFound 23 partition(s)\nFound FTPR header: FTPR partition spans from 0x180000 to 0x24a000\nME/TXE firmware version 8.1.40.1416\nPublic key match: Intel ME, firmware versions 7.x.x.x, 8.x.x.x\nThe AltMeDisable bit is NOT SET\nReading partitions list...\n ???? (0x000003c0 - 0x000000400, 0x00000040 total bytes): removed\n FOVD (0x00000400 - 0x000001000, 0x00000c00 total bytes): removed\n MDES (0x00001000 - 0x000002000, 0x00001000 total bytes): removed\n FCRS (0x00002000 - 0x000003000, 0x00001000 total bytes): removed\n EFFS (0x00003000 - 0x0000df000, 0x000dc000 total bytes): removed\n BIAL (NVRAM partition, no data, 0x0000add0 total bytes): nothing to remove\n BIEL (NVRAM partition, no data, 0x00003000 total bytes): nothing to remove\n BIIS (NVRAM partition, no data, 0x00036000 total bytes): nothing to remove\n NVCL (NVRAM partition, no data, 0x00010511 total bytes): nothing to remove\n NVCM (NVRAM partition, no data, 0x0000493f total bytes): nothing to remove\n NVCP (NVRAM partition, no data, 0x0000a553 total bytes): nothing to remove\n NVJC (NVRAM partition, no data, 0x00004000 total bytes): nothing to remove\n NVKR (NVRAM partition, no data, 0x0001257d total bytes): nothing to remove\n NVOS (NVRAM partition, no data, 0x00034af5 total bytes): nothing to remove\n NVSH (NVRAM partition, no data, 0x00007609 total bytes): nothing to remove\n NVTD (NVRAM partition, no data, 0x00001eac total bytes): nothing to remove\n PLDM (NVRAM partition, no data, 0x0000a000 total bytes): nothing to remove\n GLUT (0x000df000 - 0x0000e3000, 0x00004000 total bytes): removed\n LOCL (0x000e3000 - 0x0000e7000, 0x00004000 total bytes): removed\n WCOD (0x000e7000 - 0x000140000, 0x00059000 total bytes): removed\n MDMV (0x00140000 - 0x000180000, 0x00040000 total bytes): removed\n FTPR (0x00180000 - 0x00024a000, 0x000ca000 total bytes): NOT removed\n NFTP (0x0024a000 - 0x0004a4000, 0x0025a000 total bytes): removed\nRemoving partition entries in FPT...\nRemoving EFFS presence flag...\nCorrecting checksum (0x2f)...\nReading FTPR modules list...\n UPDATE           (LZMA   , 0x1cc507 - 0x1cc6c5       ): removed\n ROMP             (Huffman, fragmented data, ~2 KiB   ): NOT removed, essential\n BUP              (Huffman, fragmented data, ~56 KiB  ): NOT removed, essential\n KERNEL           (Huffman, fragmented data, ~135 KiB ): removed\n POLICY           (Huffman, fragmented data, ~91 KiB  ): removed\n HOSTCOMM         (LZMA   , 0x1cc6c5 - 0x1d349f       ): removed\n RSA              (LZMA   , 0x1d349f - 0x1d86f5       ): removed\n CLS              (LZMA   , 0x1d86f5 - 0x1dde8a       ): removed\n TDT              (LZMA   , 0x1dde8a - 0x1e4580       ): removed\n FTCS             (Huffman, fragmented data, ~18 KiB  ): removed\n ClsPriv          (LZMA   , 0x1e4580 - 0x1e4961       ): removed\n SESSMGR          (LZMA   , 0x1e4961 - 0x1f328b       ): removed\nThe ME minimum size should be 1667072 bytes (0x197000 bytes)\nThe ME region can be reduced up to:\n 00003000:00199fff me\nSetting the AltMeDisable bit in PCHSTRP10 to disable Intel ME...\nChecking the FTPR RSA signature... VALID\nDone! Good luck!\n"})})})]}),"\n",(0,o.jsx)(n.h2,{id:"flash-the-neutralized-intel-me",children:"Flash the Neutralized Intel ME"}),"\n",(0,o.jsx)(n.p,{children:"Now flash the full factory image with the neutralized Intel ME:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'sudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V" -w factory_me_neutralized.bin\n'})}),"\n",(0,o.jsx)(n.p,{children:"To double-check, you can dump the newly flashed image"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'sudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V" -r flashed.bin\n'})}),"\n",(0,o.jsx)(n.p,{children:"Next, use sha1sum to compare the dumped BIOS image with the original libreboot_bottom.rom file"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"sha1sum factory_me_neutralized.bin flashed.bin\n"})}),"\n",(0,o.jsx)(n.p,{children:"If the hashes match, you should see something like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"4b9f06ccd2ce11dad757e337829a450a05df7929  factory_me_neutralized.bin\n4b9f06ccd2ce11dad757e337829a450a05df7929  flashed.bin\n"})}),"\n",(0,o.jsx)(n.p,{children:"Once you've confirmed that the hashes are the same, you can clean up any temporary dump files:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"rm -fr flashed.bin\n"})}),"\n",(0,o.jsx)(n.h2,{id:"flash-the-coreboot-bios-region",children:"Flash the Coreboot BIOS Region"}),"\n",(0,o.jsx)(n.p,{children:"Before flashing the BIOS, remove the CMOS battery. Some laptops use CMOS/EC settings to protect the SPI chip, and removing the battery also adds a layer of safety."}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsx)(n.p,{children:"If you\u2019ve already flashed Coreboot internally, you can skip this section as you\u2019re all set and ready to go."})}),"\n",(0,o.jsx)(n.p,{children:"Make sure the writing protection is disabled:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'sudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V" --wp-disable\n'})}),"\n",(0,o.jsx)(n.p,{children:"You will get the below output:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:"Disabled hardware protection\n"})}),"\n",(0,o.jsx)(n.p,{children:"Now flash ONLY the BIOS region from your Coreboot image by doing:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'sudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V" -w coreboot.rom --ifd -i bios -N\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Finally, ",(0,o.jsx)(n.a,{href:"/docs/coreboot/internal/flashing#verify-the-flashed-image",children:"verify"})," the flashed bios region."]}),"\n",(0,o.jsx)(n.h2,{id:"verify-intel-me-neutralization",children:"Verify Intel ME Neutralization"}),"\n",(0,o.jsxs)(n.p,{children:["To check whether Intel ME has been successfully neutralized, you can use ",(0,o.jsx)(n.code,{children:"intelmetool"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"cd coreboot/util/intelmetool\nmake\nsudo ./intelmetool -m\n"})}),"\n",(0,o.jsx)(n.p,{children:"The output you want to see should look similar to this:"}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Output"}),(0,o.jsx)("p",{children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:"Bad news, you have a `QM77 Express Chipset LPC Controller` so you have ME hardware on board and you can't control or disable it, continuing...\n\nMEI found: [8086:1e3a] 7 Series/C216 Chipset Family MEI Controller #1\n\nME Status   : 0x1c020191\nME Status 2 : 0x120a0150\n\nME: FW Partition Table      : OK\nME: Bringup Loader Failure  : NO\nME: Firmware Init Complete  : NO\nME: Manufacturing Mode      : YES\nME: Boot Options Present    : NO\nME: Update In Progress      : NO\nME: Current Working State   : Initializing\nME: Current Operation State : Bring up\nME: Current Operation Mode  : Debug\nME: Error Code              : No Error\nME: Progress Phase          : BUP Phase\nME: Power Management Event  : Clean global reset\nME: Progress Phase State    : Check to see if straps say ME DISABLED\n\nME: Extend SHA-256: f9acfe9c2b5b199d321a1580417f5c4334d710175ad70bdaf4350eb1bef276fe\n\nME: failed to become ready\nME: failed to become ready\nME: GET FW VERSION message failed\n"})})})]}),"\n",(0,o.jsx)(n.p,{children:"In this output, Intel ME remains in the initializing state and fails to become fully ready. This is exactly what you expect when ME has been neutralized: the hardware is present, but the ME firmware is disabled and cannot initialize."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var r=t(6540);const o={},a=r.createContext(o);function i(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);