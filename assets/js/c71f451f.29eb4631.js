"use strict";(self.webpackChunkmy_personal_website=self.webpackChunkmy_personal_website||[]).push([[5500],{1114:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>f,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"coreboot/external-flashing","title":"External Flashing","description":"External flashing is sometimes necessary instead of internal flashing. The main reasons are:","source":"@site/docs/coreboot/external-flashing.mdx","sourceDirName":"coreboot","slug":"/coreboot/external-flashing/","permalink":"/docs/coreboot/external-flashing/","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"coreboot","permalink":"/docs/tags/coreboot"},{"inline":true,"label":"chipsec","permalink":"/docs/tags/chipsec"},{"inline":true,"label":"bios","permalink":"/docs/tags/bios"},{"inline":true,"label":"external","permalink":"/docs/tags/external"},{"inline":true,"label":"flashing","permalink":"/docs/tags/flashing"}],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"External Flashing","slug":"/coreboot/external-flashing/","tags":["coreboot","chipsec","bios","external","flashing"]},"sidebar":"tutorialCoreboot","previous":{"title":"Internal Flashing","permalink":"/docs/coreboot/internal-flashing/"}}');var r=t(4848),a=t(8453),i=t(1662);const s={sidebar_position:7,title:"External Flashing",slug:"/coreboot/external-flashing/",tags:["coreboot","chipsec","bios","external","flashing"]},l="External Flashing",d={},c=[{value:"Detect the Chip",id:"detect-the-chip",level:2},{value:"Backup the Factory Bios",id:"backup-the-factory-bios",level:2},{value:"Neutralize Intel ME",id:"neutralize-intel-me",level:2},{value:"After Flashing Coreboot",id:"after-flashing-coreboot",level:3},{value:"Before Flashing Coreboot",id:"before-flashing-coreboot",level:3},{value:"Step 1 \u2013 Neutralize Intel ME",id:"step-1--neutralize-intel-me",level:4},{value:"Step 2 \u2013 Split the factory BIOS into regions",id:"step-2--split-the-factory-bios-into-regions",level:4},{value:"Step 3 \u2013 Extract the BIOS region from your Coreboot image",id:"step-3--extract-the-bios-region-from-your-coreboot-image",level:4},{value:"Step 4 \u2013 Reassemble the final flash image",id:"step-4--reassemble-the-final-flash-image",level:4},{value:"Flash the Coreboot BIOS",id:"flash-the-coreboot-bios",level:2},{value:"Verify the Flashed Image",id:"verify-the-flashed-image",level:2},{value:"Verify Intel ME Neutralization",id:"verify-intel-me-neutralization",level:2}];function h(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"external-flashing",children:"External Flashing"})}),"\n",(0,r.jsx)(n.p,{children:"External flashing is sometimes necessary instead of internal flashing. The main reasons are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Neutralizing Intel ME"}),": Internal flashing can\u2019t access the ME region on stock firmware, so an external flash is required the first time if you want to disable or neutralize Intel ME."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recovery"}),": If an internal flash fails and the laptop no longer boots, an external programmer is the only way to restore the system."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hardware restrictions"}),": Some motherboards simply don\u2019t allow internal flashing at all, so external flashing is the only option."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"detect-the-chip",children:"Detect the Chip"}),"\n",(0,r.jsx)(n.p,{children:"Now, you need to detect the chip model using flashrom. To ensure accurate detection, follow these steps for the BIOS chip:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Based on your BIOS Chip type (",(0,r.jsx)(n.code,{children:"SOIC"})," or ",(0,r.jsx)(n.code,{children:"WSON"}),") Connect the Raspberry Pico to your Pomona Clip (1st photo) or Pogo Pin Adapter (2nd photo) using Dupont cables, as showed in Libreboot guide."]}),"\n",(0,r.jsx)(n.li,{children:"Plug/Insert onto the BIOS chip firmly"}),"\n",(0,r.jsx)(n.li,{children:"Plug the Raspberry Pico into the laptop using a USB cable"}),"\n"]}),"\n","\n",(0,r.jsxs)(i.Ay,{container:!0,spacing:2,children:[(0,r.jsx)(i.Ay,{item:!0,xs:12,sm:6,md:6,style:{textAlign:"center"},children:(0,r.jsx)("img",{src:"/img/libreboot/connection.jpg",alt:"Connection Setup",style:{width:"100%",maxWidth:"100%"}})}),(0,r.jsx)(i.Ay,{item:!0,xs:12,sm:6,md:6,style:{textAlign:"center"},children:(0,r.jsx)("img",{src:"/img/coreboot/connection.jpg",alt:"Connection Clip",style:{width:"100%",maxWidth:"100%"}})})]}),"\n",(0,r.jsx)(n.p,{children:"Execute the following command to detect the chip"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"sudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M\n"})}),"\n",(0,r.jsx)(n.p,{children:"If multiple chips are detected, verify whether the one you previously photographed or one closely resembling it is present. Subsequently, re-run the command, making sure to specify the name of the pertinent chip."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'sudo flashprog -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V"\n'})}),"\n",(0,r.jsx)(n.p,{children:"If the Raspberry Pico detects the chip, you may proceed by creating a backup."}),"\n",(0,r.jsx)(n.h2,{id:"backup-the-factory-bios",children:"Backup the Factory Bios"}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"If you are coming from a unsuccessful internal flashing, you can skip this part as there is no point to dump a bios that does not work."})}),"\n",(0,r.jsx)(n.p,{children:"To create a reliable backup of the BIOS chip(s), it's advisable to perform a triple dump of them"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'sudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V" -r factory.bin\nsudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V" -r factory2.bin\nsudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V" -r factory3.bin\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Next, use ",(0,r.jsx)(n.code,{children:"sha1sum"})," to compare the dumped BIOS images"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"sha1sum factory.bin factory.bin factory.bin\n"})}),"\n",(0,r.jsx)(n.p,{children:"If the hashes match, you should see something like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"6cf9bfc90df1ed01336872cd159a00c101d0a7b0  factory.bin\n6cf9bfc90df1ed01336872cd159a00c101d0a7b0  factory2.bin\n6cf9bfc90df1ed01336872cd159a00c101d0a7b0  factory3.bin\n"})}),"\n",(0,r.jsx)(n.p,{children:"Once you've confirmed that the hashes are the same, you can clean up any temporary dump files:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"rm -fr factory2.bin factory3.bin\n"})}),"\n",(0,r.jsx)(n.h2,{id:"neutralize-intel-me",children:"Neutralize Intel ME"}),"\n",(0,r.jsx)(n.p,{children:"You have two ways to disable Intel ME"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"After Coreboot is already flashed (RECOMMENDED)"}),": This is the safer and easier method. You simply dump the BIOS from the SPI chip, neutralize Intel ME using me_cleaner, and then flash the modified ME region back externally."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Before flashing Coreboot for the first time"}),": This method is more complex and requires extra caution. You need to extract the factory BIOS, modify the Intel ME region, and then combine it with your Coreboot image before flashing."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"after-flashing-coreboot",children:"After Flashing Coreboot"}),"\n",(0,r.jsxs)(n.p,{children:["Check if the dumped image has the correct structure by using ",(0,r.jsx)(n.code,{children:"ifdtool"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cd coreboot/util/ifdtool\nmake\n./ifdtool -d factory.bin\n"})}),"\n",(0,r.jsx)(n.p,{children:"It should print a long output, including the section related to Intel ME:"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Output"}),(0,r.jsx)("p",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Warning: No platform specified. Output may be incomplete\nFile t430s_full_dump_coreboot.bin is 16777216 bytes\nPCH Revision: 6 series Cougar Point\nFLMAP0:    0x03040003\n  NR:      3\n  FRBA:    0x40\n  NC:      1\n  FCBA:    0x30\nFLMAP1:    0x12100206\n  ISL:     0x12\n  FPSBA:   0x100\n  NM:      2\n  FMBA:    0x60\nFLMAP2:    0x00210120\n  PSL:     0x2101\n  FMSBA:   0x200\nFLUMAP1:   0x000018df\n  Intel ME VSCC Table Length (VTL):        24\n  Intel ME VSCC Table Base Address (VTBA): 0x000df0\n\nME VSCC table:\n  JID0:  0x001620c2\n    SPI Component Vendor ID:            0xc2\n    SPI Component Device ID 0:          0x20\n    SPI Component Device ID 1:          0x16\n  VSCC0: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n  JID1:  0x001720c2\n    SPI Component Vendor ID:            0xc2\n    SPI Component Device ID 0:          0x20\n    SPI Component Device ID 1:          0x17\n  VSCC1: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n  JID2:  0x001820c2\n    SPI Component Vendor ID:            0xc2\n    SPI Component Device ID 0:          0x20\n    SPI Component Device ID 1:          0x18\n  VSCC2: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n  JID3:  0x001640ef\n    SPI Component Vendor ID:            0xef\n    SPI Component Device ID 0:          0x40\n    SPI Component Device ID 1:          0x16\n  VSCC3: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n  JID4:  0x001740ef\n    SPI Component Vendor ID:            0xef\n    SPI Component Device ID 0:          0x40\n    SPI Component Device ID 1:          0x17\n  VSCC4: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n  JID5:  0x001840ef\n    SPI Component Vendor ID:            0xef\n    SPI Component Device ID 0:          0x40\n    SPI Component Device ID 1:          0x18\n  VSCC5: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n  JID6:  0x0016ba20\n    SPI Component Vendor ID:            0x20\n    SPI Component Device ID 0:          0xba\n    SPI Component Device ID 1:          0x16\n  VSCC6: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n  JID7:  0x0017ba20\n    SPI Component Vendor ID:            0x20\n    SPI Component Device ID 0:          0xba\n    SPI Component Device ID 1:          0x17\n  VSCC7: 0x20052005\n    Lower Erase Opcode:                 0x20\n    Lower Write Enable on Write Status: 0x50\n    Lower Write Status Required:        No\n    Lower Write Granularity:            64 bytes\n    Lower Block / Sector Erase Size:    4KB\n    Upper Erase Opcode:                 0x20\n    Upper Write Enable on Write Status: 0x50\n    Upper Write Status Required:        No\n    Upper Write Granularity:            64 bytes\n    Upper Block / Sector Erase Size:    4KB\n\nOEM Section:\n00: 47 31 52 4e 31 36 57 57 ff 38 2e 31 2e 34 30 2e\n10: 31 34 31 36 ff 31 36 4d 42 ff 53 49 47 4e 45 44\n20: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n30: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n\nFound Region Section\nFLREG0:    0x00000000\n  Flash Region 0 (Flash Descriptor): 00000000 - 00000fff \nFLREG1:    0x0fff0500\n  Flash Region 1 (BIOS): 00500000 - 00ffffff \nFLREG2:    0x04ff0003\n  Flash Region 2 (Intel ME): 00003000 - 004fffff \nFLREG3:    0x00020001\n  Flash Region 3 (GbE): 00001000 - 00002fff \nFLREG4:    0x00001fff\n  Flash Region 4 (Platform Data): 00fff000 - 00000fff (unused)\n\nFound Component Section\nFLCOMP     0x4990001d\n  Dual Output Fast Read Support:       supported\n  Read ID/Read Status Clock Frequency: 33MHz\n  Write/Erase Clock Frequency:         33MHz\n  Fast Read Clock Frequency:           50MHz\n  Fast Read Support:                   supported\n  Read Clock Frequency:                20MHz\n  Component 2 Density:                 4MB\n  Component 1 Density:                 16MB\nFLILL      0x00000000\n  Invalid Instruction 3: 0x00\n  Invalid Instruction 2: 0x00\n  Invalid Instruction 1: 0x00\n  Invalid Instruction 0: 0x00\nFLPB       0x00000000\n  Flash Partition Boundary Address: 0x000000\n\nFound PCH Strap Section\nPCHSTRP0  : 0x4810d782\nPCHSTRP1  : 0x0000010f\nPCHSTRP2  : 0x00000000\nPCHSTRP3  : 0x00000000\nPCHSTRP4  : 0x00c8e102\nPCHSTRP5  : 0x00000000\nPCHSTRP6  : 0x00000000\nPCHSTRP7  : 0x00000000\nPCHSTRP8  : 0x00000000\nPCHSTRP9  : 0x30000b8c\nPCHSTRP10 : 0x00410044\nPCHSTRP11 : 0x99000097\nPCHSTRP12 : 0x00000000\nPCHSTRP13 : 0x00000000\nPCHSTRP14 : 0x00000000\nPCHSTRP15 : 0x0000437e\nPCHSTRP16 : 0x00000000\nPCHSTRP17 : 0x00000002\nAltMeDisable bit is not set\n\nFound Master Section\nFLMSTR1:   0x0a0b0000 (Host CPU/BIOS)\n  Platform Data Region Write Access: disabled\n  GbE Region Write Access:           enabled\n  Intel ME Region Write Access:      disabled\n  Host CPU/BIOS Region Write Access: enabled\n  Flash Descriptor Write Access:     disabled\n  Platform Data Region Read Access:  disabled\n  GbE Region Read Access:            enabled\n  Intel ME Region Read Access:       disabled\n  Host CPU/BIOS Region Read Access:  enabled\n  Flash Descriptor Read Access:      enabled\n  Requester ID:                      0x0000\n\nFLMSTR2:   0x0c0d0000 (Intel ME)\n  Platform Data Region Write Access: disabled\n  GbE Region Write Access:           enabled\n  Intel ME Region Write Access:      enabled\n  Host CPU/BIOS Region Write Access: disabled\n  Flash Descriptor Write Access:     disabled\n  Platform Data Region Read Access:  disabled\n  GbE Region Read Access:            enabled\n  Intel ME Region Read Access:       enabled\n  Host CPU/BIOS Region Read Access:  disabled\n  Flash Descriptor Read Access:      enabled\n  Requester ID:                      0x0000\n\nFLMSTR3:   0x08080118 (GbE)\n  Platform Data Region Write Access: disabled\n  GbE Region Write Access:           enabled\n  Intel ME Region Write Access:      disabled\n  Host CPU/BIOS Region Write Access: disabled\n  Flash Descriptor Write Access:     disabled\n  Platform Data Region Read Access:  disabled\n  GbE Region Read Access:            enabled\n  Intel ME Region Read Access:       disabled\n  Host CPU/BIOS Region Read Access:  disabled\n  Flash Descriptor Read Access:      disabled\n  Requester ID:                      0x0118\n\nFound Processor Strap Section\n????:      0x00000000\n????:      0xffffffff\n????:      0xffffffff\n????:      0xffffffff\n????:      0xffffffff\n????:      0xffffffff\n????:      0xffffffff\n????:      0xffffffff\n"})})})]}),"\n",(0,r.jsx)(n.p,{children:"Now to check if the dumped ME image is valid just run:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"python me_cleaner.py -c factory.bin\n"})}),"\n",(0,r.jsx)(n.p,{children:"You should get an output like the one below:"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Output"}),(0,r.jsx)("p",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Full image detected\nThe ME/TXE region goes from 0x3000 to 0x500000\nFound FPT header at 0x3010\nFound 23 partition(s)\nFound FTPR header: FTPR partition spans from 0x180000 to 0x24a000\nME/TXE firmware version 8.1.40.1416\nPublic key match: Intel ME, firmware versions 7.x.x.x, 8.x.x.x\nThe AltMeDisable bit is NOT SET\nChecking the FTPR RSA signature... VALID\n"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["Apply ",(0,r.jsx)(n.code,{children:"me_cleaner"})]}),"\n",(0,r.jsxs)(n.p,{children:["To neutralize Intel ME you can just use ",(0,r.jsx)(n.code,{children:"me_cleaner"})," on it:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"python me_cleaner.py -S -O output.bin factory.bin\n"})}),"\n",(0,r.jsx)(n.p,{children:"You should get an output like the one below:"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Output"}),(0,r.jsx)("p",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Full image detected\nThe ME/TXE region goes from 0x3000 to 0x500000\nFound FPT header at 0x3010\nFound 23 partition(s)\nFound FTPR header: FTPR partition spans from 0x180000 to 0x24a000\nME/TXE firmware version 8.1.40.1416\nPublic key match: Intel ME, firmware versions 7.x.x.x, 8.x.x.x\nThe AltMeDisable bit is NOT SET\nReading partitions list...\n ???? (0x000003c0 - 0x000000400, 0x00000040 total bytes): removed\n FOVD (0x00000400 - 0x000001000, 0x00000c00 total bytes): removed\n MDES (0x00001000 - 0x000002000, 0x00001000 total bytes): removed\n FCRS (0x00002000 - 0x000003000, 0x00001000 total bytes): removed\n EFFS (0x00003000 - 0x0000df000, 0x000dc000 total bytes): removed\n BIAL (NVRAM partition, no data, 0x0000add0 total bytes): nothing to remove\n BIEL (NVRAM partition, no data, 0x00003000 total bytes): nothing to remove\n BIIS (NVRAM partition, no data, 0x00036000 total bytes): nothing to remove\n NVCL (NVRAM partition, no data, 0x00010511 total bytes): nothing to remove\n NVCM (NVRAM partition, no data, 0x0000493f total bytes): nothing to remove\n NVCP (NVRAM partition, no data, 0x0000a553 total bytes): nothing to remove\n NVJC (NVRAM partition, no data, 0x00004000 total bytes): nothing to remove\n NVKR (NVRAM partition, no data, 0x0001257d total bytes): nothing to remove\n NVOS (NVRAM partition, no data, 0x00034af5 total bytes): nothing to remove\n NVSH (NVRAM partition, no data, 0x00007609 total bytes): nothing to remove\n NVTD (NVRAM partition, no data, 0x00001eac total bytes): nothing to remove\n PLDM (NVRAM partition, no data, 0x0000a000 total bytes): nothing to remove\n GLUT (0x000df000 - 0x0000e3000, 0x00004000 total bytes): removed\n LOCL (0x000e3000 - 0x0000e7000, 0x00004000 total bytes): removed\n WCOD (0x000e7000 - 0x000140000, 0x00059000 total bytes): removed\n MDMV (0x00140000 - 0x000180000, 0x00040000 total bytes): removed\n FTPR (0x00180000 - 0x00024a000, 0x000ca000 total bytes): NOT removed\n NFTP (0x0024a000 - 0x0004a4000, 0x0025a000 total bytes): removed\nRemoving partition entries in FPT...\nRemoving EFFS presence flag...\nCorrecting checksum (0x2f)...\nReading FTPR modules list...\n UPDATE           (LZMA   , 0x1cc507 - 0x1cc6c5       ): removed\n ROMP             (Huffman, fragmented data, ~2 KiB   ): NOT removed, essential\n BUP              (Huffman, fragmented data, ~56 KiB  ): NOT removed, essential\n KERNEL           (Huffman, fragmented data, ~135 KiB ): removed\n POLICY           (Huffman, fragmented data, ~91 KiB  ): removed\n HOSTCOMM         (LZMA   , 0x1cc6c5 - 0x1d349f       ): removed\n RSA              (LZMA   , 0x1d349f - 0x1d86f5       ): removed\n CLS              (LZMA   , 0x1d86f5 - 0x1dde8a       ): removed\n TDT              (LZMA   , 0x1dde8a - 0x1e4580       ): removed\n FTCS             (Huffman, fragmented data, ~18 KiB  ): removed\n ClsPriv          (LZMA   , 0x1e4580 - 0x1e4961       ): removed\n SESSMGR          (LZMA   , 0x1e4961 - 0x1f328b       ): removed\nThe ME minimum size should be 1667072 bytes (0x197000 bytes)\nThe ME region can be reduced up to:\n 00003000:00199fff me\nSetting the AltMeDisable bit in PCHSTRP10 to disable Intel ME...\nChecking the FTPR RSA signature... VALID\nDone! Good luck!\n"})})})]}),"\n",(0,r.jsx)(n.h3,{id:"before-flashing-coreboot",children:"Before Flashing Coreboot"}),"\n",(0,r.jsx)(n.h4,{id:"step-1--neutralize-intel-me",children:"Step 1 \u2013 Neutralize Intel ME"}),"\n",(0,r.jsxs)(n.p,{children:["Apply ",(0,r.jsx)(n.code,{children:"me_cleaner"})," to the factory BIOS dump (",(0,r.jsx)(n.code,{children:"factory.bi"}),"n) and extract the neutralized Intel ME as a separate file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"python me_cleaner.py -S -M flashregion_2_intel_me_disabled.bin factory.bin\n"})}),"\n",(0,r.jsx)(n.p,{children:"The output should look similar to this:"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Output"}),(0,r.jsx)("p",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'Full image detected\nThe ME/TXE region goes from 0x3000 to 0x500000\nFound FPT header at 0x3010\nFound 23 partition(s)\nFound FTPR header: FTPR partition spans from 0x180000 to 0x24a000\nME/TXE firmware version 8.1.40.1416\nPublic key match: Intel ME, firmware versions 7.x.x.x, 8.x.x.x\nThe AltMeDisable bit is NOT SET\nReading partitions list...\n ???? (0x000003c0 - 0x000000400, 0x00000040 total bytes): removed\n FOVD (0x00000400 - 0x000001000, 0x00000c00 total bytes): removed\n MDES (0x00001000 - 0x000002000, 0x00001000 total bytes): removed\n FCRS (0x00002000 - 0x000003000, 0x00001000 total bytes): removed\n EFFS (0x00003000 - 0x0000df000, 0x000dc000 total bytes): removed\n BIAL (NVRAM partition, no data, 0x0000add0 total bytes): nothing to remove\n BIEL (NVRAM partition, no data, 0x00003000 total bytes): nothing to remove\n BIIS (NVRAM partition, no data, 0x00036000 total bytes): nothing to remove\n NVCL (NVRAM partition, no data, 0x00010511 total bytes): nothing to remove\n NVCM (NVRAM partition, no data, 0x0000493f total bytes): nothing to remove\n NVCP (NVRAM partition, no data, 0x0000a553 total bytes): nothing to remove\n NVJC (NVRAM partition, no data, 0x00004000 total bytes): nothing to remove\n NVKR (NVRAM partition, no data, 0x0001257d total bytes): nothing to remove\n NVOS (NVRAM partition, no data, 0x00034af5 total bytes): nothing to remove\n NVSH (NVRAM partition, no data, 0x00007609 total bytes): nothing to remove\n NVTD (NVRAM partition, no data, 0x00001eac total bytes): nothing to remove\n PLDM (NVRAM partition, no data, 0x0000a000 total bytes): nothing to remove\n GLUT (0x000df000 - 0x0000e3000, 0x00004000 total bytes): removed\n LOCL (0x000e3000 - 0x0000e7000, 0x00004000 total bytes): removed\n WCOD (0x000e7000 - 0x000140000, 0x00059000 total bytes): removed\n MDMV (0x00140000 - 0x000180000, 0x00040000 total bytes): removed\n FTPR (0x00180000 - 0x00024a000, 0x000ca000 total bytes): NOT removed\n NFTP (0x0024a000 - 0x0004a4000, 0x0025a000 total bytes): removed\nRemoving partition entries in FPT...\nRemoving EFFS presence flag...\nCorrecting checksum (0x2f)...\nReading FTPR modules list...\n UPDATE           (LZMA   , 0x1cc507 - 0x1cc6c5       ): removed\n ROMP             (Huffman, fragmented data, ~2 KiB   ): NOT removed, essential\n BUP              (Huffman, fragmented data, ~56 KiB  ): NOT removed, essential\n KERNEL           (Huffman, fragmented data, ~135 KiB ): removed\n POLICY           (Huffman, fragmented data, ~91 KiB  ): removed\n HOSTCOMM         (LZMA   , 0x1cc6c5 - 0x1d349f       ): removed\n RSA              (LZMA   , 0x1d349f - 0x1d86f5       ): removed\n CLS              (LZMA   , 0x1d86f5 - 0x1dde8a       ): removed\n TDT              (LZMA   , 0x1dde8a - 0x1e4580       ): removed\n FTCS             (Huffman, fragmented data, ~18 KiB  ): removed\n ClsPriv          (LZMA   , 0x1e4580 - 0x1e4961       ): removed\n SESSMGR          (LZMA   , 0x1e4961 - 0x1f328b       ): removed\nThe ME minimum size should be 1667072 bytes (0x197000 bytes)\nThe ME region can be reduced up to:\n 00003000:00199fff me\nSetting the AltMeDisable bit in PCHSTRP10 to disable Intel ME...\nExtracting the ME image to "flasregion_2_intel_me_neutralized.bin"...\nChecking the FTPR RSA signature of the extracted ME image... VALID\nChecking the FTPR RSA signature... VALID\nDone! Good luck!\n'})})})]}),"\n",(0,r.jsx)(n.h4,{id:"step-2--split-the-factory-bios-into-regions",children:"Step 2 \u2013 Split the factory BIOS into regions"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"ifdtool"})," to extract the different flash regions from ",(0,r.jsx)(n.code,{children:"factory.bin"}),". These regions will later be recombined with the Coreboot BIOS and the neutralized ME:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cd coreboot/util/ifdtool\nmake\n./ifdtool -x factory.bin\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"File factory.bin is 16777216 bytes\n  Flash Region 0 (Flash Descriptor): 00000000 - 00000fff \n  Flash Region 1 (BIOS): 00500000 - 00ffffff \n  Flash Region 2 (Intel ME): 00003000 - 004fffff\n  Flash Region 3 (GbE): 00001000 - 00002fff \n  Flash Region 4 (Platform Data): 00fff000 - 00000fff (unused)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Files created:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"flashregion_0_flashdescriptor.bin\nflashregion_1_bios.bin\nflashregion_2_intel_me.bin\nflashregion_3_gbe.bin\n"})}),"\n",(0,r.jsx)(n.p,{children:"Since we will use the neutralized Intel ME and your Coreboot BIOS, remove the original BIOS and ME files:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"rm -fr flashregion_1_bios.bin flashregion_2_intel_me.bin\n"})}),"\n",(0,r.jsx)(n.h4,{id:"step-3--extract-the-bios-region-from-your-coreboot-image",children:"Step 3 \u2013 Extract the BIOS region from your Coreboot image"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"dd"})," to extract the BIOS region from the built Coreboot ROM. Make sure to skip the offset noted from the factory BIOS output (0x500000 for the BIOS region):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"dd if=coreboot.rom of=flashregion_1_bios_coreboot.bin bs=1 skip=$((0x500000))\n"})}),"\n",(0,r.jsx)(n.h4,{id:"step-4--reassemble-the-final-flash-image",children:"Step 4 \u2013 Reassemble the final flash image"}),"\n",(0,r.jsx)(n.p,{children:"Combine the flash descriptor, Coreboot BIOS region, neutralized Intel ME, and other regions to create the final image:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cat flashregion_0_flashdescriptor.bin \\\n    flashregion_1_bios_coreboot.bin \\\n    flashregion_2_intel_me_neutralized.bin \\\n    flashregion_3_gbe.bin \\\n    > final_coreboot_me_neutralized.rom\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"The resulting final_coreboot_me_neutralized.rom is now ready for flashing."}),"\n",(0,r.jsx)(n.h2,{id:"flash-the-coreboot-bios",children:"Flash the Coreboot BIOS"}),"\n",(0,r.jsx)(n.p,{children:"Once everything looks correct:"}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"Before writing the BIOS into the chip(s), ensure to remove the CMOS battery as a security precaution."})}),"\n",(0,r.jsx)(n.p,{children:"Make sure the writing protection is disabled:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'sudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V" --wp-disable\n'})}),"\n",(0,r.jsx)(n.p,{children:"You will get the below output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Disabled hardware protection\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Flash the prepared ",(0,r.jsx)(n.code,{children:"final_coreboot_me_neutralized.rom"})," image:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'sudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V" -w final_coreboot_me_neutralized.rom\n'})}),"\n",(0,r.jsx)(n.p,{children:"You should likely get these logs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Reading ich decriptor... done.\nErasing and writing flash chip... Erase/write done.\nVerifying flash... VERIFIED.\n"})}),"\n",(0,r.jsx)(n.h2,{id:"verify-the-flashed-image",children:"Verify the Flashed Image"}),"\n",(0,r.jsxs)(n.p,{children:["After flashing, always re-read the chip and compare it against the file you wrote (",(0,r.jsx)(n.code,{children:"coreboot.rom"}),").\nThis ensures the flash was successful and the chip contains exactly what you intended."]}),"\n",(0,r.jsx)(n.p,{children:"To double-check, you can dump the newly flashed BIOS image"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'sudo flashrom -p serprog:dev=/dev/ttyACM0,spispeed=16M -c "W25Q128.V" -r flashed.bin\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Next, use sha1sum to compare the dumped BIOS image with the original ",(0,r.jsx)(n.code,{children:"final_coreboot_me_neutralized.rom"})," file"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"sha1sum final_coreboot_me_neutralized.rom flashed.bin\n"})}),"\n",(0,r.jsx)(n.p,{children:"If the hashes match, you should see something like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"42489cdfda9666177cd9abc1876f4dea258f7ab8  final_coreboot_me_neutralized.rom\n42489cdfda9666177cd9abc1876f4dea258f7ab8  flashed.bin\n"})}),"\n",(0,r.jsx)(n.p,{children:"Once you've confirmed that the hashes are the same, you can clean up any temporary dump files:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"rm -fr flashed.bin\n"})}),"\n",(0,r.jsx)(n.p,{children:"Your new Coreboot firmware has been flashed correctly and is ready to boot!"}),"\n",(0,r.jsx)(n.h2,{id:"verify-intel-me-neutralization",children:"Verify Intel ME Neutralization"}),"\n",(0,r.jsxs)(n.p,{children:["To check whether Intel ME has been successfully neutralized, you can use ",(0,r.jsx)(n.code,{children:"intelmetool"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cd coreboot/util/intelmetool\nmake\nsudo ./intelmetool -m\n"})}),"\n",(0,r.jsx)(n.p,{children:"The output you want to see should look similar to this:"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Output"}),(0,r.jsx)("p",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Bad news, you have a `QM77 Express Chipset LPC Controller` so you have ME hardware on board and you can't control or disable it, continuing...\n\nMEI found: [8086:1e3a] 7 Series/C216 Chipset Family MEI Controller #1\n\nME Status   : 0x1c020191\nME Status 2 : 0x120a0150\n\nME: FW Partition Table      : OK\nME: Bringup Loader Failure  : NO\nME: Firmware Init Complete  : NO\nME: Manufacturing Mode      : YES\nME: Boot Options Present    : NO\nME: Update In Progress      : NO\nME: Current Working State   : Initializing\nME: Current Operation State : Bring up\nME: Current Operation Mode  : Debug\nME: Error Code              : No Error\nME: Progress Phase          : BUP Phase\nME: Power Management Event  : Clean global reset\nME: Progress Phase State    : Check to see if straps say ME DISABLED\n\nME: Extend SHA-256: f9acfe9c2b5b199d321a1580417f5c4334d710175ad70bdaf4350eb1bef276fe\n\nME: failed to become ready\nME: failed to become ready\nME: GET FW VERSION message failed\n"})})})]}),"\n",(0,r.jsx)(n.p,{children:"In this output, Intel ME remains in the initializing state and fails to become fully ready. This is exactly what you expect when ME has been neutralized: the hardware is present, but the ME firmware is disabled and cannot initialize."})]})}function f(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var o=t(6540);const r={},a=o.createContext(r);function i(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);