"use strict";(self.webpackChunkmy_personal_website=self.webpackChunkmy_personal_website||[]).push([[4616],{5694:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>A,contentTitle:()=>N,default:()=>D,frontMatter:()=>B,metadata:()=>r,toc:()=>V});const r=JSON.parse('{"id":"basics/private-keys/derivation-path","title":"Derivation Path","description":"A derivation path determines how your private keys are derived from your seed phrase and which addresses are generated from those keys.","source":"@site/docs/basics/private-keys/derivation-path.mdx","sourceDirName":"basics/private-keys","slug":"/basics/private-keys/derivation-path","permalink":"/docs/basics/private-keys/derivation-path","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"private keys","permalink":"/docs/tags/private-keys"},{"inline":true,"label":"derivation path","permalink":"/docs/tags/derivation-path"},{"inline":true,"label":"bip39","permalink":"/docs/tags/bip-39"},{"inline":true,"label":"seed","permalink":"/docs/tags/seed"}],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Derivation Path","slug":"/basics/private-keys/derivation-path","tags":["private keys","derivation path","bip39","seed"]},"sidebar":"tutorialBasics","previous":{"title":"Passphrase","permalink":"/docs/basics/private-keys/passphrase"},"next":{"title":"Extended Private Key (XPRV)","permalink":"/docs/basics/private-keys/xprv"}}');var n=t(4848),a=t(8453),i=t(6540),l=t(8215),c=t(7559),d=t(3104),o=t(6347),h=t(205),u=t(7485),p=t(1682),x=t(679);function f(e){return i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:s}=e;return!!s&&"object"==typeof s&&"value"in s}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function v(e){const{values:s,children:t}=e;return(0,i.useMemo)((()=>{const e=s??function(e){return f(e).map((({props:{value:e,label:s,attributes:t,default:r}})=>({value:e,label:s,attributes:t,default:r})))}(t);return function(e){const s=(0,p.XI)(e,((e,s)=>e.value===s.value));if(s.length>0)throw new Error(`Docusaurus error: Duplicate values "${s.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[s,t])}function m({value:e,tabValues:s}){return s.some((s=>s.value===e))}function j({queryString:e=!1,groupId:s}){const t=(0,o.W6)(),r=function({queryString:e=!1,groupId:s}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!s)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return s??null}({queryString:e,groupId:s});return[(0,u.aZ)(r),(0,i.useCallback)((e=>{if(!r)return;const s=new URLSearchParams(t.location.search);s.set(r,e),t.replace({...t.location,search:s.toString()})}),[r,t])]}function b(e){const{defaultValue:s,queryString:t=!1,groupId:r}=e,n=v(e),[a,l]=(0,i.useState)((()=>function({defaultValue:e,tabValues:s}){if(0===s.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:s}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${s.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=s.find((e=>e.default))??s[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:s,tabValues:n}))),[c,d]=j({queryString:t,groupId:r}),[o,u]=function({groupId:e}){const s=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,r]=(0,x.Dv)(s);return[t,(0,i.useCallback)((e=>{s&&r.set(e)}),[s,r])]}({groupId:r}),p=(()=>{const e=c??o;return m({value:e,tabValues:n})?e:null})();(0,h.A)((()=>{p&&l(p)}),[p]);return{selectedValue:a,selectValue:(0,i.useCallback)((e=>{if(!m({value:e,tabValues:n}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),u(e)}),[d,u,n]),tabValues:n}}var g=t(2303);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function w({className:e,block:s,selectedValue:t,selectValue:r,tabValues:a}){const i=[],{blockElementScrollPositionUntilNextRender:c}=(0,d.a_)(),o=e=>{const s=e.currentTarget,n=i.indexOf(s),l=a[n].value;l!==t&&(c(s),r(l))},h=e=>{let s=null;switch(e.key){case"Enter":o(e);break;case"ArrowRight":{const t=i.indexOf(e.currentTarget)+1;s=i[t]??i[0];break}case"ArrowLeft":{const t=i.indexOf(e.currentTarget)-1;s=i[t]??i[i.length-1];break}}s?.focus()};return(0,n.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.A)("tabs",{"tabs--block":s},e),children:a.map((({value:e,label:s,attributes:r})=>(0,n.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{i.push(e)},onKeyDown:h,onClick:o,...r,className:(0,l.A)("tabs__item",y.tabItem,r?.className,{"tabs__item--active":t===e}),children:s??e},e)))})}function k({lazy:e,children:s,selectedValue:t}){const r=(Array.isArray(s)?s:[s]).filter(Boolean);if(e){const e=r.find((e=>e.props.value===t));return e?(0,i.cloneElement)(e,{className:(0,l.A)("margin-top--md",e.props.className)}):null}return(0,n.jsx)("div",{className:"margin-top--md",children:r.map(((e,s)=>(0,i.cloneElement)(e,{key:s,hidden:e.props.value!==t})))})}function P(e){const s=b(e);return(0,n.jsxs)("div",{className:(0,l.A)(c.G.tabs.container,"tabs-container",y.tabList),children:[(0,n.jsx)(w,{...s,...e}),(0,n.jsx)(k,{...s,...e})]})}function T(e){const s=(0,g.A)();return(0,n.jsx)(P,{...e,children:f(e.children)},String(s))}const I={tabItem:"tabItem_Ymn6"};function S({children:e,hidden:s,className:t}){return(0,n.jsx)("div",{role:"tabpanel",className:(0,l.A)(I.tabItem,t),hidden:s,children:e})}const B={sidebar_position:6,title:"Derivation Path",slug:"/basics/private-keys/derivation-path",tags:["private keys","derivation path","bip39","seed"]},N="Derivation Path",A={},V=[{value:"The BIP32 Standard",id:"the-bip32-standard",level:2},{value:"Anatomy of a Derivation Path",id:"anatomy-of-a-derivation-path",level:2},{value:"Common Derivation Paths",id:"common-derivation-paths",level:2},{value:"BIP-44 (Universal Path for Multiple Coins)",id:"bip-44-universal-path-for-multiple-coins",level:4},{value:"BIP-49 (Pay-to-Script-Hash with SegWit)",id:"bip-49-pay-to-script-hash-with-segwit",level:4},{value:"BIP-84 (Native SegWit with Bech32)",id:"bip-84-native-segwit-with-bech32",level:4},{value:"BIP-86 (Taproot with Bech32m)",id:"bip-86-taproot-with-bech32m",level:4}];function q(e){const s={code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"derivation-path",children:"Derivation Path"})}),"\n",(0,n.jsx)(s.p,{children:"A derivation path determines how your private keys are derived from your seed phrase and which addresses are generated from those keys."}),"\n",(0,n.jsx)(s.h2,{id:"the-bip32-standard",children:"The BIP32 Standard"}),"\n",(0,n.jsx)(s.p,{children:"The BIP32 (Bitcoin Improvement Proposal) standard defines how hierarchical deterministic (HD) wallets work. HD wallets use a tree-like structure where every branch can produce a new keypair (private and public key). This means you only need to back up the seed phrase, and the wallet can regenerate all keys and addresses from that phrase."}),"\n",(0,n.jsx)(s.h2,{id:"anatomy-of-a-derivation-path",children:"Anatomy of a Derivation Path"}),"\n",(0,n.jsx)(s.p,{children:"A typical derivation path looks like this:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-text",children:"m / 44' / 0' / 0' / 0 / 0\n"})}),"\n",(0,n.jsx)(s.p,{children:"Here\u2019s what each part means:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"m"})," - The master node (your seed phrase). This is the root of the tree."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"44'"})," - The purpose or protocol. The apostrophe ('), known as the hardened separator, indicates that these keys are hardened for security."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0'"})," - The coin type. ",(0,n.jsx)(s.strong,{children:"For Bitcoin, this is always 0"})," (but for other cryptocurrencies, it would be a different number)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0'"})," - The account. A wallet can have multiple accounts, each with its own address."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0"})," - The change type (0 for external addresses, 1 for internal addresses like change)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0"})," - The address index. This is used to generate a new address each time."]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"common-derivation-paths",children:"Common Derivation Paths"}),"\n",(0,n.jsx)(s.p,{children:"Here are some of the most common derivation paths used in Bitcoin wallets:"}),"\n",(0,n.jsxs)(T,{queryString:"derivation-path",children:[(0,n.jsxs)(S,{value:"bip44",label:"BIP44",children:[(0,n.jsx)(s.h4,{id:"bip-44-universal-path-for-multiple-coins",children:"BIP-44 (Universal Path for Multiple Coins)"}),(0,n.jsx)(s.p,{children:"BIP-44 is the most widely used standard for creating wallets that manage multiple cryptocurrencies. It\u2019s designed to support multi-asset wallets and has a clear, structured path for generating different addresses."}),(0,n.jsx)(s.p,{children:"Standard Path:"}),(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-text",children:"m / 44' / 0' / 0' / 0 / 0\n"})}),(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"44'"}),": Indicates the wallet follows BIP-44 for multi-asset support."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0'"}),": This specifies the Bitcoin coin type."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0'"}),": Refers to the first account in the wallet."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0"}),": The external addresses (i.e., the ones used to receive funds)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0"}),": The first address in the external address list."]}),"\n"]}),(0,n.jsxs)(s.p,{children:["Addresses starts with ",(0,n.jsx)(s.code,{children:"1"}),":"]}),(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-text",children:"137oszRjc8tdUVWr5nSp6fzSND938PStMZ\n"})})]}),(0,n.jsxs)(S,{value:"bip49",label:"BIP49",children:[(0,n.jsx)(s.h4,{id:"bip-49-pay-to-script-hash-with-segwit",children:"BIP-49 (Pay-to-Script-Hash with SegWit)"}),(0,n.jsx)(s.p,{children:"BIP-49 defines a path for creating P2SH (Pay-to-Script-Hash) addresses, a type of Bitcoin address that begins with 3. This path is used for SegWit transactions, improving transaction efficiency and lowering fees."}),(0,n.jsx)(s.p,{children:"Standard Path:"}),(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-text",children:"m / 49' / 0' / 0' / 0 / 0\n"})}),(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"49'"}),": Indicates SegWit addresses that start with 3 (P2SH)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0'"}),": Specifies Bitcoin as the coin type."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0'"}),": Refers to the first account."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0"}),": External addresses."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0"}),": The first address for receiving."]}),"\n"]}),(0,n.jsxs)(s.p,{children:["Addresses starts with ",(0,n.jsx)(s.code,{children:"3"}),":"]}),(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-text",children:"33S43b6qmVHVTjwp75M7XoTTPEvKVh8zqH\n"})})]}),(0,n.jsxs)(S,{value:"bip84",label:"BIP84",children:[(0,n.jsx)(s.h4,{id:"bip-84-native-segwit-with-bech32",children:"BIP-84 (Native SegWit with Bech32)"}),(0,n.jsx)(s.p,{children:"BIP-84 is used to generate native SegWit addresses, which start with bc1q and are more efficient than older types of Bitcoin addresses. These addresses have a lower transaction fee and are fully compatible with the SegWit protocol."}),(0,n.jsx)(s.p,{children:"Standard Path:"}),(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-text",children:"m / 84' / 0' / 0' / 0 / 0\n"})}),(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"84'"}),": Specifies ",(0,n.jsx)(s.strong,{children:"native SegWit"})," addresses (starting with bc1q)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0'"}),": The coin type for Bitcoin."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0'"}),": The first account."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0"}),": External addresses."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0"}),": The first address."]}),"\n"]}),(0,n.jsxs)(s.p,{children:["Addresses starts with ",(0,n.jsx)(s.code,{children:"bc1"}),":"]}),(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-text",children:"bc1q6khgephuq2hyvrn49zrvsxztmtjg4ze7sxkpp4\n"})})]}),(0,n.jsxs)(S,{value:"bip86",label:"BIP86",children:[(0,n.jsx)(s.h4,{id:"bip-86-taproot-with-bech32m",children:"BIP-86 (Taproot with Bech32m)"}),(0,n.jsxs)(s.p,{children:["BIP-86 is used to generate Taproot addresses, which start with ",(0,n.jsx)(s.code,{children:"bc1p"}),". These addresses improve privacy and efficiency by leveraging Schnorr signatures and Merkelized Abstract Syntax Trees (MAST)."]}),(0,n.jsx)(s.p,{children:"Standard Path:"}),(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-text",children:"m / 86' / 0' / 0' / 0 / 0\n"})}),(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"86'"}),": Specifies ",(0,n.jsx)(s.strong,{children:"Taproot"})," addresses (starting with bc1p)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0'"}),": The coin type for Bitcoin."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0'"}),": The first account."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0"}),": External addresses."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0"}),": The first address."]}),"\n"]}),(0,n.jsxs)(s.p,{children:["Addresses start with ",(0,n.jsx)(s.code,{children:"bc1p"}),":"]}),(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-text",children:"bc1ps3yjzpnxeg9yx43f9zmrl9njhvlwh4pm5peuu5ucqqp7f4362cvqeesncf\n"})})]})]})]})}function D(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(q,{...e})}):q(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>i,x:()=>l});var r=t(6540);const n={},a=r.createContext(n);function i(e){const s=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),r.createElement(a.Provider,{value:s},e.children)}}}]);